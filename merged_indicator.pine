// MERGED SCRIPT : Hourly Open + ICT Imbalances + NWOG/NDOG + HTF Candles
// Combines:
//    1. "Hourly Open & Separator"                (original author unknown)
//    2. "ICT – GAPS, Volume & Price Imbalances"  © Vulnerable_human_x
//    3. "ICT NWOG/NDOG (fadi)"                   © fadizeidan
//    4. "ICT HTF Candles (fadi)"                 © fadizeidan
// Licence: Mozilla Public License 2.0

//@version=6
indicator(
	 "Hourly Open + ICT Imbalances + NWOG/NDOG + HTF Candles (Merged)",
	 shorttitle  = "HO + Imbal + NWOG + HTF [Merged]",
	 overlay = true,
	 max_boxes_count = 500,
	 max_lines_count = 500,
	 max_labels_count = 500,
	 max_bars_back = 5000,
	 behind_chart = true,
	 dynamic_requests = true)

var bool ENABLE_HOURLY_OPEN=input.bool(true, "Enable Hourly Open & Separator", group="⓪ Section Toggles")
var bool ENABLE_ORDER_BLOCKS=input.bool(true, "Enable Order Blocks", group="⓪ Section Toggles")
var bool ENABLE_IMBALANCES=input.bool(true, "Enable ICT Imbalances (FVG/VI/GAP)", group="⓪ Section Toggles")
var bool ENABLE_NWOG_NDOG=input.bool(true, "Enable NWOG / NDOG", group="⓪ Section Toggles")
var bool ENABLE_HTF_CANDLES=input.bool(true, "Enable HTF Candles", group="⓪ Section Toggles")
var bool ENABLE_KILLZONES=input.bool(true, "Enable Killzones", group="⓪ Section Toggles")
var bool ENABLE_SESSION_HL=input.bool(true, "Enable Session Highs/Lows", group="⓪ Section Toggles")
var bool ENABLE_LIQUIDITY=input.bool(true, "Enable PDH/PDL/PWH/PWL", group="⓪ Section Toggles")
var bool ENABLE_REJECTION_BLK=input.bool(true, "Enable Rejection Blocks", group="⓪ Section Toggles")
var bool ENABLE_BREAKER_MIT=input.bool(true, "Enable Breaker / Mitigation", group="⓪ Section Toggles")
var bool ENABLE_PDA_SCANNER=input.bool(false, "Enable PD Array Scanner", group="⓪ Section Toggles")

var bool wh_enable=input.bool(false, "Enable Webhook Alerts", group="㉑ Webhook Alerts", tooltip="JSON alerts via alert(). In TV alert dialog, select 'Any alert() function call'.")
var bool wh_formations=input.bool(true, "Formation Alerts", group="㉑ Webhook Alerts", inline="wh1", tooltip="OB/FVG/VI/GAP formations")
var bool wh_mitigations=input.bool(true, "Mitigation Alerts", group="㉑ Webhook Alerts", inline="wh1", tooltip="Mitigation events")

_wh_json(string _event, float _high, float _low) =>
	'{"event":"' + _event + '","ticker":"' + syminfo.ticker + '","exchange":"' + syminfo.prefix + '","timeframe":"' + timeframe.period + '","price_high":' + str.tostring(_high, format.mintick) + ',"price_low":' + str.tostring(_low, format.mintick) + ',"close":' + str.tostring(close, format.mintick) + ',"time":"' + str.format_time(time, "yyyy-MM-dd HH:mm:ss", "America/New_York") + '"}'

var color ho_lineColor=input.color(color.black , "Hourly Line" , group="① Hourly Open", inline="ho1")
var string ho_styleInput=input.string("Solid" , "", options=["Solid","Dotted","Dashed","Arrow Left","Arrow Right","Arrow Both"], group="① Hourly Open", inline="ho1")
var int ho_width=input.int(1 , "", 1, 4, group="① Hourly Open", inline="ho1")
var bool ho_extendMidnight=input.bool(true , "Extend Midnight" , group="① Hourly Open", inline="ho2")
var bool ho_showMidnightLbl=input.bool(true , "Show Label", group="① Hourly Open", inline="ho2")
var color ho_midColor=input.color(color.purple , "Midnight Line", group="① Hourly Open", inline="ho3")
var string ho_midStyleInput=input.string("Solid" , "", options=["Solid","Dotted","Dashed","Arrow Left","Arrow Right","Arrow Both"], group="① Hourly Open", inline="ho3")
var int ho_midWidth=input.int(1 , "", 1, 4, group="① Hourly Open", inline="ho3")
var int ho_midDays=input.int(5, "Midnight Days", 1, 20, group="① Hourly Open", inline="ho3b", tooltip="Midnight opens to show (1-20).")
var color ho_midLblColor=input.color(color.purple, "Label", group="① Hourly Open", inline="ho3b")
var string ho_midLblSize=input.string("Small", "", options=['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'Huge'], group="① Hourly Open", inline="ho3b")
var int ho_maxLines=input.int(50, "Max Lines", 1, 100, group="① Hourly Open")

var bool ho_highlightFirst10=input.bool(false , "First 10 Min", group="① Hourly Open", inline="ho4")
var color ho_firstClr=input.color(color.red , "", group="① Hourly Open", inline="ho4")
var bool ho_highlightLast10=input.bool(false , "Last 10 Min" , group="① Hourly Open", inline="ho5")
var color ho_lastClr=input.color(color.red , "" , group="① Hourly Open", inline="ho5")
var int ho_highlightWidth=input.int(2 , "", 1, 4, group="① Hourly Open", inline="ho5")

var color hs_lineColor=input.color(color.new(color.red,0),"Separator Line", group="② Hourly Separator", inline="hs1")
var string hs_lineStyleOpt=input.string("Dotted","", options=["Solid","Dashed","Dotted"], group="② Hourly Separator", inline="hs1")
var string hs_lineWidthOpt=input.string("1","", options=["1","2","3"], group="② Hourly Separator", inline="hs1")
var int hs_maxLines=input.int(50,"Max Lines", 1,100, group="② Hourly Separator")

line_style(_opt) =>
	switch _opt
		"Solid"       => line.style_solid
		"Dotted"      => line.style_dotted
		"Dashed"      => line.style_dashed
		"Arrow Left"  => line.style_arrow_left
		"Arrow Right" => line.style_arrow_right
		"Arrow Both"  => line.style_arrow_both
		=> line.style_solid

f_get_line_style(style) =>
	out = switch style
		'⎯⎯⎯'  => line.style_solid
		'----' => line.style_dashed
		'····' => line.style_dotted

var line[] ho_lines=array.new_line()
var line[] hs_lines=array.new_line()

var float[] ho_midPrices=array.new_float()
var int[] ho_midBars=array.new_int()
var int[] ho_midTimes=array.new_int()
var line[] ho_midLines=array.new_line()
var label[] ho_midLabels=array.new_label()
var bool ho_wasMidnight=false

_ho_getSize(_s) =>
	_s == "Auto" ? size.auto : _s == "Small" ? size.small : _s == "Normal" ? size.normal : _s == "Large" ? size.large : _s == "Huge" ? size.huge : size.tiny

int _midnHour = syminfo.timezone == "America/Chicago" ? 23 : 0

if timeframe.isintraday and ENABLE_HOURLY_OPEN
	bool _isMidnight = hour == _midnHour and minute == 0
	if _isMidnight and not ho_wasMidnight
		array.unshift(ho_midPrices, open)
		array.unshift(ho_midBars, bar_index)
		array.unshift(ho_midTimes, time)
		array.unshift(ho_midLines, line(na))
		array.unshift(ho_midLabels, label(na))
		while array.size(ho_midPrices) > ho_midDays
			array.pop(ho_midPrices)
			array.pop(ho_midBars)
			array.pop(ho_midTimes)
			line.delete(array.pop(ho_midLines))
			label.delete(array.pop(ho_midLabels))
	ho_wasMidnight := _isMidnight

	if ho_extendMidnight and array.size(ho_midPrices) > 0
		string _midSz = _ho_getSize(ho_midLblSize)
		for i = 0 to array.size(ho_midPrices) - 1
			float _price = array.get(ho_midPrices, i)
			int _startBar = array.get(ho_midBars, i)
			int _startTime = array.get(ho_midTimes, i)
			int _x2 = bar_index + 20
			string _dayStr = str.format_time(_startTime, "EEE MM/dd", "America/New_York")
			string _txt = "Midnight Open " + str.tostring(_price, format.mintick) + " (" + _dayStr + ")"
			line _ln = array.get(ho_midLines, i)
			if na(_ln)
				_ln := line.new(_startBar, _price, _x2, _price, color = ho_midColor, style = line_style(ho_midStyleInput), width = ho_midWidth)
				array.set(ho_midLines, i, _ln)
			line.set_x2(_ln, _x2)
			line.set_color(_ln, ho_midColor)
			line.set_width(_ln, ho_midWidth)
			line.set_style(_ln, line_style(ho_midStyleInput))
			if ho_showMidnightLbl
				label _lbl = array.get(ho_midLabels, i)
				if na(_lbl)
					_lbl := label.new(_x2, _price, _txt, style = label.style_label_left, color = color.new(color.white, 100), textcolor = ho_midLblColor, size = _midSz)
					array.set(ho_midLabels, i, _lbl)
				label.set_x(_lbl, _x2)
				label.set_text(_lbl, _txt)
				label.set_textcolor(_lbl, ho_midLblColor)
				label.set_size(_lbl, _midSz)

	if minute == 0 and second == 0 and hour != _midnHour
		int segStart = time
		int segFirstEnd = time + 10*60*1000
		int segLastStart = time + 50*60*1000
		int segEnd = time + 60*60*1000

		line _main = line.new(segStart, open, segEnd, open,
								xloc.bar_time, color=ho_lineColor,
								style=line_style(ho_styleInput),
								width=ho_width)
		array.push(ho_lines, _main)

		if ho_highlightFirst10
			array.push(ho_lines,
					   line.new(segStart, open, segFirstEnd, open, xloc.bar_time,
								color=ho_firstClr, style=line_style(ho_styleInput), width=ho_highlightWidth))
		if ho_highlightLast10
			array.push(ho_lines,
					   line.new(segLastStart, open, segEnd, open, xloc.bar_time,
								color=ho_lastClr , style=line_style(ho_styleInput), width=ho_highlightWidth))

while array.size(ho_lines) > ho_maxLines
	line.delete(array.shift(ho_lines))

bool hs_newHour = minute == 0 and minute[1] > 0
if hs_newHour and ENABLE_HOURLY_OPEN
	line _sep = line.new(bar_index, low - ta.tr, bar_index, high + ta.tr,
						 xloc.bar_index, extend.both,
						 hs_lineColor,
						 hs_lineStyleOpt=="Solid"?line.style_solid:hs_lineStyleOpt=="Dashed"?line.style_dashed:line.style_dotted,
						 hs_lineWidthOpt=="3"?3:hs_lineWidthOpt=="2"?2:1)
	array.push(hs_lines, _sep)

while array.size(hs_lines) > hs_maxLines
	line.delete(array.shift(hs_lines))

var bool ob_showBull=input.bool(true, "Bullish OB", group="③ Order Blocks", inline="ob1")
var color ob_bullColor=input.color(color.new(#00e640, 80), "", group="③ Order Blocks", inline="ob1")
var bool ob_showBear=input.bool(true, "Bearish OB", group="③ Order Blocks", inline="ob2")
var color ob_bearColor=input.color(color.new(#e30000, 80), "", group="③ Order Blocks", inline="ob2")
var string ob_zone=input.string("Body", "Zone / Border", options=["Body", "Full Range"], group="③ Order Blocks", inline="ob3", tooltip="Body=open-close. Full Range=high-low.")
var string ob_borderStyle=input.string("Solid", "", options=["Solid", "Dashed", "Dotted"], group="③ Order Blocks", inline="ob3")

var bool ob_extend=input.bool(true, "Extend", group="③ Order Blocks", inline="ob4")
var bool ob_showLabel=input.bool(true, "Label", group="③ Order Blocks", inline="ob4")
var color ob_mitColor=input.color(color.new(color.gray, 92), "Mit.", group="③ Order Blocks", inline="ob4")
var bool ob_showMT=input.bool(true, "Mean Threshold", group="③ Order Blocks", inline="ob4b", tooltip="50% OB midpoint.")
var color ob_mtColor=input.color(color.new(color.white, 60), "", group="③ Order Blocks", inline="ob4b")
var bool ob_invert=input.bool(false, "Invert Mitigated", group="③ Order Blocks", inline="ob5", tooltip="Mitigated OB flips direction.")
var color ob_invBullColor=input.color(color.new(#e30000, 75), "", group="③ Order Blocks", inline="ob5")
var color ob_invBearColor=input.color(color.new(#00e640, 75), "", group="③ Order Blocks", inline="ob5")
var int ob_maxBoxes=input.int(20, "Max Boxes", 1, 50, group="③ Order Blocks", inline="ob6")
var int ob_pruneAge=input.int(500, "Prune After", 0, 5000, group="③ Order Blocks", inline="ob6", tooltip="Auto-prune after N bars. 0=off.")
var int ob_maxBlend=input.int(3, "Max Blend", 1, 5, group="③ Order Blocks", inline="ob7", tooltip="Max candles to blend into one OB.")
var float ob_displacement=input.float(0, "Min Displacement", 0, 10, step=0.5, group="③ Order Blocks", inline="ob7b", tooltip="Min displacement multiple. 0=off.")

var string OB_MTF_GRP="③ᵇ MTF Order Blocks"
var bool ob_mtf1_show=input.bool(false, "HTF 1", group=OB_MTF_GRP, inline="mtf1")
var string ob_mtf1_tf=input.timeframe("60", "", group=OB_MTF_GRP, inline="mtf1", tooltip="HTF1. Uses ③ settings.")
var color ob_mtf1_bullClr=input.color(color.new(#00e640, 65), "", group=OB_MTF_GRP, inline="mtf1")
var color ob_mtf1_bearClr=input.color(color.new(#e30000, 65), "", group=OB_MTF_GRP, inline="mtf1")
var bool ob_mtf2_show=input.bool(false, "HTF 2", group=OB_MTF_GRP, inline="mtf2")
var string ob_mtf2_tf=input.timeframe("240", "", group=OB_MTF_GRP, inline="mtf2", tooltip="HTF2.")
var color ob_mtf2_bullClr=input.color(color.new(#00e640, 55), "", group=OB_MTF_GRP, inline="mtf2")
var color ob_mtf2_bearClr=input.color(color.new(#e30000, 55), "", group=OB_MTF_GRP, inline="mtf2")
var bool ob_mtf3_show=input.bool(false, "HTF 3", group=OB_MTF_GRP, inline="mtf3")
var string ob_mtf3_tf=input.timeframe("D", "", group=OB_MTF_GRP, inline="mtf3", tooltip="HTF3.")
var color ob_mtf3_bullClr=input.color(color.new(#00e640, 45), "", group=OB_MTF_GRP, inline="mtf3")
var color ob_mtf3_bearClr=input.color(color.new(#e30000, 45), "", group=OB_MTF_GRP, inline="mtf3")
var int ob_mtf_maxBoxes=input.int(10, "Max Boxes / Layer ", 1, 30, group=OB_MTF_GRP, inline="mtf_cfg", tooltip="Max/layer.")

type OrderBlock
	box bx
	line mtLine
	float bodyTop
	float bodyBot
	bool isBull
	bool mitigated
	int mit_bar

var array<OrderBlock> ob_bulls=array.new<OrderBlock>()
var array<OrderBlock> ob_bears=array.new<OrderBlock>()

bool ob_bullFormed = false
bool ob_bearFormed = false
bool ob_bullMit = false
bool ob_bearMit = false

ob_border = switch ob_borderStyle
	"Solid"  => line.style_solid
	"Dashed" => line.style_dashed
	"Dotted" => line.style_dotted
	=> line.style_solid

if barstate.isconfirmed and ENABLE_ORDER_BLOCKS

	if ob_showBull and close > open
		int _cnt = 0
		float _bTop = na
		float _bBot = na
		float _hi = na
		float _lo = na
		int _sIdx = na
		for j = 1 to ob_maxBlend
			if close[j] < open[j]
				_cnt += 1
				_bTop := na(_bTop) ? open[j] : math.max(_bTop, open[j])
				_bBot := na(_bBot) ? close[j] : math.min(_bBot, close[j])
				_hi := na(_hi) ? high[j] : math.max(_hi, high[j])
				_lo := na(_lo) ? low[j] : math.min(_lo, low[j])
				_sIdx := bar_index - j
			else
				break

		if _cnt > 0 and close > _bTop
			float _bodyH = _bTop - _bBot
			bool _dispOk = ob_displacement <= 0 or (_bodyH > 0 and (close - _bTop) >= ob_displacement * _bodyH)
			if _dispOk
				float _top = ob_zone == "Body" ? _bTop : _hi
				float _bot = ob_zone == "Body" ? _bBot : _lo
				box _bx = box.new(_sIdx, _top, bar_index, _bot,
					 bgcolor = ob_bullColor,
					 border_color = color.new(ob_bullColor, 60),
					 border_style = ob_border,
					 border_width = 1,
					 text         = ob_showLabel ? "Bull OB" : na,
					 text_halign = text.align_left,
					 text_valign = text.align_top,
					 text_size = size.tiny,
					 text_color = color.new(ob_bullColor, 30))
				float _mt = (_bTop + _bBot) / 2
				line _mtL = ob_showMT ? line.new(_sIdx, _mt, bar_index, _mt,
					 color = ob_mtColor, style = line.style_dashed, width = 1) : na
				ob_bulls.push(OrderBlock.new(_bx, _mtL, _bTop, _bBot, true, false, 0))
				ob_bullFormed := true
				if wh_enable and wh_formations
					alert(_wh_json("Bull OB Formed", _top, _bot), alert.freq_once_per_bar_close)
				while ob_bulls.size() > ob_maxBoxes
					OrderBlock _del = ob_bulls.shift()
					box.delete(_del.bx)
					if not na(_del.mtLine)
						line.delete(_del.mtLine)

	if ob_showBear and close < open
		int _cnt = 0
		float _bTop = na
		float _bBot = na
		float _hi = na
		float _lo = na
		int _sIdx = na
		for j = 1 to ob_maxBlend
			if close[j] > open[j]
				_cnt += 1
				_bTop := na(_bTop) ? close[j] : math.max(_bTop, close[j])
				_bBot := na(_bBot) ? open[j] : math.min(_bBot, open[j])
				_hi := na(_hi) ? high[j] : math.max(_hi, high[j])
				_lo := na(_lo) ? low[j] : math.min(_lo, low[j])
				_sIdx := bar_index - j
			else
				break

		if _cnt > 0 and close < _bBot
			float _bodyH = _bTop - _bBot
			bool _dispOk = ob_displacement <= 0 or (_bodyH > 0 and (_bBot - close) >= ob_displacement * _bodyH)
			if _dispOk
				float _top = ob_zone == "Body" ? _bTop : _hi
				float _bot = ob_zone == "Body" ? _bBot : _lo
				box _bx = box.new(_sIdx, _top, bar_index, _bot,
					 bgcolor = ob_bearColor,
					 border_color = color.new(ob_bearColor, 60),
					 border_style = ob_border,
					 border_width = 1,
					 text         = ob_showLabel ? "Bear OB" : na,
					 text_halign = text.align_left,
					 text_valign = text.align_bottom,
					 text_size = size.tiny,
					 text_color = color.new(ob_bearColor, 30))
				float _mt = (_bTop + _bBot) / 2
				line _mtL = ob_showMT ? line.new(_sIdx, _mt, bar_index, _mt,
					 color = ob_mtColor, style = line.style_dashed, width = 1) : na
				ob_bears.push(OrderBlock.new(_bx, _mtL, _bTop, _bBot, false, false, 0))
				ob_bearFormed := true
				if wh_enable and wh_formations
					alert(_wh_json("Bear OB Formed", _top, _bot), alert.freq_once_per_bar_close)
				while ob_bears.size() > ob_maxBoxes
					OrderBlock _del = ob_bears.shift()
					box.delete(_del.bx)
					if not na(_del.mtLine)
						line.delete(_del.mtLine)

f_obManage(_arr, _isBull) =>
	bool _mit = false
	color _invClr = _isBull ? ob_invBullColor : ob_invBearColor
	string _invTxt = _isBull ? "Inv Bear OB" : "Inv Bull OB"
	string _alertTxt = _isBull ? "Bull OB Mitigated" : "Bear OB Mitigated"
	for i = _arr.size() - 1 to 0 by 1
		OrderBlock _ob = _arr.get(i)
		if not _ob.mitigated
			bool _hitMit = _isBull ? (barstate.isconfirmed and close < _ob.bodyBot) : (barstate.isconfirmed and close > _ob.bodyTop)
			if _hitMit
				_ob.mitigated := true
				_ob.mit_bar := bar_index
				_mit := true
				if wh_enable and wh_mitigations
					alert(_wh_json(_alertTxt, box.get_top(_ob.bx), box.get_bottom(_ob.bx)), alert.freq_once_per_bar)
				if ob_invert
					box.set_bgcolor(_ob.bx, _invClr)
					box.set_border_color(_ob.bx, color.new(_invClr, 60))
					box.set_text_color(_ob.bx, color.new(_invClr, 30))
					box.set_text(_ob.bx, ob_showLabel ? _invTxt : na)
				else
					box.set_bgcolor(_ob.bx, ob_mitColor)
					box.set_border_color(_ob.bx, ob_mitColor)
					box.set_text_color(_ob.bx, color.new(color.gray, 70))
				if not na(_ob.mtLine)
					line.set_color(_ob.mtLine, ob_invert ? color.new(_invClr, 60) : color.new(color.gray, 85))
			else if ob_extend
				box.set_right(_ob.bx, bar_index + 1)
				if not na(_ob.mtLine)
					line.set_x2(_ob.mtLine, bar_index + 1)
		else
			if ob_invert and ob_extend
				box.set_right(_ob.bx, bar_index + 1)
				if not na(_ob.mtLine)
					line.set_x2(_ob.mtLine, bar_index + 1)
			if ob_pruneAge > 0 and (bar_index - _ob.mit_bar) > ob_pruneAge
				box.delete(_ob.bx)
				if not na(_ob.mtLine)
					line.delete(_ob.mtLine)
				_arr.remove(i)
		true
	_mit

if ENABLE_ORDER_BLOCKS and ob_bulls.size() > 0
	ob_bullMit := f_obManage(ob_bulls, true)
if ENABLE_ORDER_BLOCKS and ob_bears.size() > 0
	ob_bearMit := f_obManage(ob_bears, false)

f_obScan(int _blend, float _disp) =>
	var int _bullSeq=0
	var float _bullBT=na
	var float _bullBB=na
	var float _bullHi=na
	var float _bullLo=na
	var int _bearSeq=0
	var float _bearBT=na
	var float _bearBB=na
	var float _bearHi=na
	var float _bearLo=na
	if barstate.isconfirmed
		if close > open
			int _cnt = 0
			float _bTop = na
			float _bBot = na
			float _hi = na
			float _lo = na
			for j = 1 to _blend
				if close[j] < open[j]
					_cnt += 1
					_bTop := na(_bTop) ? open[j] : math.max(_bTop, open[j])
					_bBot := na(_bBot) ? close[j] : math.min(_bBot, close[j])
					_hi := na(_hi) ? high[j] : math.max(_hi, high[j])
					_lo := na(_lo) ? low[j] : math.min(_lo, low[j])
				else
					break
			if _cnt > 0 and close > _bTop
				float _bodyH = _bTop - _bBot
				bool _dispOk = _disp <= 0 or (_bodyH > 0 and (close - _bTop) >= _disp * _bodyH)
				if _dispOk
					_bullSeq += 1
					_bullBT := _bTop
					_bullBB := _bBot
					_bullHi := _hi
					_bullLo := _lo
		if close < open
			int _cnt = 0
			float _bTop = na
			float _bBot = na
			float _hi = na
			float _lo = na
			for j = 1 to _blend
				if close[j] > open[j]
					_cnt += 1
					_bTop := na(_bTop) ? close[j] : math.max(_bTop, close[j])
					_bBot := na(_bBot) ? open[j] : math.min(_bBot, open[j])
					_hi := na(_hi) ? high[j] : math.max(_hi, high[j])
					_lo := na(_lo) ? low[j] : math.min(_lo, low[j])
				else
					break
			if _cnt > 0 and close < _bBot
				float _bodyH = _bTop - _bBot
				bool _dispOk = _disp <= 0 or (_bodyH > 0 and (_bBot - close) >= _disp * _bodyH)
				if _dispOk
					_bearSeq += 1
					_bearBT := _bTop
					_bearBB := _bBot
					_bearHi := _hi
					_bearLo := _lo
	[_bullSeq, _bullBT, _bullBB, _bullHi, _bullLo,
	 _bearSeq, _bearBT, _bearBB, _bearHi, _bearLo]

f_tfStr(string _tf) =>
	float _n = str.tonumber(_tf)
	if not na(_n)
		int _m = int(_n)
		_m >= 1440 ? str.tostring(_m / 1440) + "D" :
		 _m >= 60  ? str.tostring(_m / 60) + "H"   :
		 str.tostring(_m) + "m"
	else
		_tf

[mtf1_bSq, mtf1_bBT, mtf1_bBB, mtf1_bHi, mtf1_bLo,
 mtf1_sSq, mtf1_sBT, mtf1_sBB, mtf1_sHi, mtf1_sLo] =
	 request.security(syminfo.tickerid, ob_mtf1_tf, f_obScan(ob_maxBlend, ob_displacement))

[mtf2_bSq, mtf2_bBT, mtf2_bBB, mtf2_bHi, mtf2_bLo,
 mtf2_sSq, mtf2_sBT, mtf2_sBB, mtf2_sHi, mtf2_sLo] =
	 request.security(syminfo.tickerid, ob_mtf2_tf, f_obScan(ob_maxBlend, ob_displacement))

[mtf3_bSq, mtf3_bBT, mtf3_bBB, mtf3_bHi, mtf3_bLo,
 mtf3_sSq, mtf3_sBT, mtf3_sBB, mtf3_sHi, mtf3_sLo] =
	 request.security(syminfo.tickerid, ob_mtf3_tf, f_obScan(ob_maxBlend, ob_displacement))

var array<OrderBlock> ob_mtf1=array.new<OrderBlock>()
var array<OrderBlock> ob_mtf2=array.new<OrderBlock>()
var array<OrderBlock> ob_mtf3=array.new<OrderBlock>()

var int _prevM1b=0
var int _prevM1s=0
var int _prevM2b=0
var int _prevM2s=0
var int _prevM3b=0
var int _prevM3s=0

f_mtfObCreate(array<OrderBlock> _arr, bool _isBull, float _bodyTop, float _bodyBot,
			  float _hi, float _lo, color _clr, string _label, int _maxBox) =>
	float _top = ob_zone == "Body" ? _bodyTop : _hi
	float _bot = ob_zone == "Body" ? _bodyBot : _lo
	box _bx = box.new(bar_index, _top, bar_index, _bot,
		 bgcolor = _clr,
		 border_color = color.new(_clr, 60),
		 border_style = ob_border,
		 border_width = 1,
		 text = ob_showLabel ? _label : na,
		 text_halign = text.align_left,
		 text_valign = _isBull ? text.align_top : text.align_bottom,
		 text_size = size.tiny,
		 text_color = color.new(_clr, 30))
	float _mt = (_bodyTop + _bodyBot) / 2
	line _mtL = ob_showMT ? line.new(bar_index, _mt, bar_index, _mt,
		 color = ob_mtColor, style = line.style_dashed, width = 1) : na
	_arr.push(OrderBlock.new(_bx, _mtL, _bodyTop, _bodyBot, _isBull, false, 0))
	while _arr.size() > _maxBox
		OrderBlock _del = _arr.shift()
		box.delete(_del.bx)
		if not na(_del.mtLine)
			line.delete(_del.mtLine)

f_mtfObManage(array<OrderBlock> _arr) =>
	if _arr.size() > 0
		for i = _arr.size() - 1 to 0 by 1
			OrderBlock _ob = _arr.get(i)
			if not _ob.mitigated
				bool _hit = _ob.isBull ? (close < _ob.bodyBot) : (close > _ob.bodyTop)
				if _hit and barstate.isconfirmed
					_ob.mitigated := true
					_ob.mit_bar := bar_index
					if ob_invert
						color _invClr = _ob.isBull ? ob_invBullColor : ob_invBearColor
						box.set_bgcolor(_ob.bx, _invClr)
						box.set_border_color(_ob.bx, color.new(_invClr, 60))
						box.set_text_color(_ob.bx, color.new(_invClr, 30))
						string _invTxt = _ob.isBull ? "Inv Bear" : "Inv Bull"
						box.set_text(_ob.bx, ob_showLabel ? _invTxt : na)
						if not na(_ob.mtLine)
							line.set_color(_ob.mtLine, color.new(_invClr, 60))
					else
						box.set_bgcolor(_ob.bx, ob_mitColor)
						box.set_border_color(_ob.bx, ob_mitColor)
						box.set_text_color(_ob.bx, color.new(color.gray, 70))
						if not na(_ob.mtLine)
							line.set_color(_ob.mtLine, color.new(color.gray, 85))
				else if ob_extend
					box.set_right(_ob.bx, bar_index + 1)
					if not na(_ob.mtLine)
						line.set_x2(_ob.mtLine, bar_index + 1)
			else
				if ob_invert and ob_extend
					box.set_right(_ob.bx, bar_index + 1)
					if not na(_ob.mtLine)
						line.set_x2(_ob.mtLine, bar_index + 1)
				if ob_pruneAge > 0 and (bar_index - _ob.mit_bar) > ob_pruneAge
					_arr.remove(i)
					box.delete(_ob.bx)
					if not na(_ob.mtLine)
						line.delete(_ob.mtLine)

f_mtfObTick() =>
	string _tf1Lbl = f_tfStr(ob_mtf1_tf)
	string _tf2Lbl = f_tfStr(ob_mtf2_tf)
	string _tf3Lbl = f_tfStr(ob_mtf3_tf)
	int _pm1b = _prevM1b
	int _pm1s = _prevM1s
	int _pm2b = _prevM2b
	int _pm2s = _prevM2s
	int _pm3b = _prevM3b
	int _pm3s = _prevM3s

	if ob_mtf1_show
		if mtf1_bSq != _pm1b
			_pm1b := mtf1_bSq
			f_mtfObCreate(ob_mtf1, true, mtf1_bBT, mtf1_bBB, mtf1_bHi, mtf1_bLo,
				 ob_mtf1_bullClr, "Bull OB (" + _tf1Lbl + ")", ob_mtf_maxBoxes)
			if wh_enable and wh_formations
				float _t = ob_zone == "Body" ? mtf1_bBT : mtf1_bHi
				float _b = ob_zone == "Body" ? mtf1_bBB : mtf1_bLo
				alert(_wh_json("Bull OB " + _tf1Lbl + " Formed", _t, _b), alert.freq_once_per_bar_close)
		if mtf1_sSq != _pm1s
			_pm1s := mtf1_sSq
			f_mtfObCreate(ob_mtf1, false, mtf1_sBT, mtf1_sBB, mtf1_sHi, mtf1_sLo,
				 ob_mtf1_bearClr, "Bear OB (" + _tf1Lbl + ")", ob_mtf_maxBoxes)
			if wh_enable and wh_formations
				float _t = ob_zone == "Body" ? mtf1_sBT : mtf1_sHi
				float _b = ob_zone == "Body" ? mtf1_sBB : mtf1_sLo
				alert(_wh_json("Bear OB " + _tf1Lbl + " Formed", _t, _b), alert.freq_once_per_bar_close)
		f_mtfObManage(ob_mtf1)

	if ob_mtf2_show
		if mtf2_bSq != _pm2b
			_pm2b := mtf2_bSq
			f_mtfObCreate(ob_mtf2, true, mtf2_bBT, mtf2_bBB, mtf2_bHi, mtf2_bLo,
				 ob_mtf2_bullClr, "Bull OB (" + _tf2Lbl + ")", ob_mtf_maxBoxes)
			if wh_enable and wh_formations
				float _t = ob_zone == "Body" ? mtf2_bBT : mtf2_bHi
				float _b = ob_zone == "Body" ? mtf2_bBB : mtf2_bLo
				alert(_wh_json("Bull OB " + _tf2Lbl + " Formed", _t, _b), alert.freq_once_per_bar_close)
		if mtf2_sSq != _pm2s
			_pm2s := mtf2_sSq
			f_mtfObCreate(ob_mtf2, false, mtf2_sBT, mtf2_sBB, mtf2_sHi, mtf2_sLo,
				 ob_mtf2_bearClr, "Bear OB (" + _tf2Lbl + ")", ob_mtf_maxBoxes)
			if wh_enable and wh_formations
				float _t = ob_zone == "Body" ? mtf2_sBT : mtf2_sHi
				float _b = ob_zone == "Body" ? mtf2_sBB : mtf2_sLo
				alert(_wh_json("Bear OB " + _tf2Lbl + " Formed", _t, _b), alert.freq_once_per_bar_close)
		f_mtfObManage(ob_mtf2)

	if ob_mtf3_show
		if mtf3_bSq != _pm3b
			_pm3b := mtf3_bSq
			f_mtfObCreate(ob_mtf3, true, mtf3_bBT, mtf3_bBB, mtf3_bHi, mtf3_bLo,
				 ob_mtf3_bullClr, "Bull OB (" + _tf3Lbl + ")", ob_mtf_maxBoxes)
			if wh_enable and wh_formations
				float _t = ob_zone == "Body" ? mtf3_bBT : mtf3_bHi
				float _b = ob_zone == "Body" ? mtf3_bBB : mtf3_bLo
				alert(_wh_json("Bull OB " + _tf3Lbl + " Formed", _t, _b), alert.freq_once_per_bar_close)
		if mtf3_sSq != _pm3s
			_pm3s := mtf3_sSq
			f_mtfObCreate(ob_mtf3, false, mtf3_sBT, mtf3_sBB, mtf3_sHi, mtf3_sLo,
				 ob_mtf3_bearClr, "Bear OB (" + _tf3Lbl + ")", ob_mtf_maxBoxes)
			if wh_enable and wh_formations
				float _t = ob_zone == "Body" ? mtf3_sBT : mtf3_sHi
				float _b = ob_zone == "Body" ? mtf3_sBB : mtf3_sLo
				alert(_wh_json("Bear OB " + _tf3Lbl + " Formed", _t, _b), alert.freq_once_per_bar_close)
		f_mtfObManage(ob_mtf3)
	[_pm1b, _pm1s, _pm2b, _pm2s, _pm3b, _pm3s]

if ENABLE_ORDER_BLOCKS
	[_m1b, _m1s, _m2b, _m2s, _m3b, _m3s] = f_mtfObTick()
	_prevM1b := _m1b
	_prevM1s := _m1s
	_prevM2b := _m2b
	_prevM2s := _m2s
	_prevM3b := _m3b
	_prevM3s := _m3s

vitype=input.string('Classic', 'Type              ', options=['None', 'Classic', 'Advanced'], group='④ Volume Imbalance', inline='vi0', tooltip='Classic=single. Advanced=all.')
bullimbalance=input.color(color.new(#00e640, 90), '', group='④ Volume Imbalance', inline='vi0')
bearimbalance=input.color(color.new(#e30000, 90), '', group='④ Volume Imbalance', inline='vi0')

bool classicvi  = vitype == 'Classic'
bool advancedvi = vitype == 'Advanced'

viMaxBoxSet=input.int(8, title='Max Boxes         ', minval=1, maxval=100, group='④ Volume Imbalance', inline='vi1')
vimitigationtype=input.string('Engulf', options=['Engulf', 'Mitigate'], group='④ Volume Imbalance', inline='vi1', tooltip='Engulf=body through.')
extendvibox=input.bool(true, title='Extend Unmit.     ', group='④ Volume Imbalance', inline='vi2')
extendallvis=input.bool(false, title='Extend All', group='④ Volume Imbalance', inline='vi2')

gaptype=input.string('True GAP', 'Type              ', options=['None', 'True GAP', 'GAP + Inefficiency'], group='⑤ GAP', inline='gp0', tooltip='True=no delivery. +Eff=one-sided.')
gapcolor=input.color(color.new(#4ec1f7, 90), '', group='⑤ GAP', inline='gp0')

bool truegap    = gaptype == 'True GAP'
bool gapwithimb = gaptype == 'GAP + Inefficiency'

gapsMaxBoxSet=input.int(7, title='Max Boxes         ', minval=1, maxval=100, group='⑤ GAP', inline='gp1')
gapmitigationtype=input.string('Engulf', options=['Engulf', 'Rebalance'], group='⑤ GAP', inline='gp1', tooltip='Engulf=body through. Rebalance=erased.')
cegap=input.bool(true, title='C.E. Line         ', group='⑤ GAP', inline='gp2')
cegaplinetype=input.string(line.style_dashed, '', options=[line.style_dashed, line.style_dotted, line.style_solid], group='⑤ GAP', inline='gp2')
extendgapbox=input.bool(true, title='Extend Unmit.', group='⑤ GAP', inline='gp2')

fvgtype=input.string('Normal', 'FVG Type          ', options=['None', 'Normal', 'Liquidity Void'], group='⑥ FVG', inline='fv0', tooltip='Consecutive FVGs=LV.')
showifvg=input.bool(false, 'Implied', group='⑥ FVG', inline='fv0')
Inversefvgmode=input.bool(false, 'Inverse', group='⑥ FVG', inline='fv0', tooltip='Requires ENGULF.')

bool plotFVG           = fvgtype == 'Normal'
bool liquidityvoidmode = fvgtype == 'Liquidity Void'

fvgBullColor=input.color(color.new(color.green, 90), title='FVG Colors        ', inline='fv1', group='⑥ FVG')
fvgBearColor=input.color(color.new(color.red, 90), inline='fv1', group='⑥ FVG')

ifvgBullColor=input.color(color.new(color.green, 90), title='Imp.FVG           ', inline='fv2', group='⑥ FVG')
ifvgBearColor=input.color(color.new(color.red, 90), inline='fv2', group='⑥ FVG')

buinvfvgcolor=input.color(color.new(#fbc02d, 94), title='Inv.FVG           ', inline='fv3', group='⑥ FVG')
beinvfvgcolor=input.color(color.new(#fbc02d, 94), inline='fv3', group='⑥ FVG')

fvgMaxBoxSet=input.int(15, title='FVG Box Limit     ', minval=1, maxval=100, group='⑥ FVG', inline='fv4')
invfvgMaxBoxSet=input.int(4, title='Inv.', minval=1, maxval=100, group='⑥ FVG', inline='fv4')
fvgmitigationtype=input.string('Engulf', title='FVG Mitigation    ', options=['Engulf', 'Mitigate', 'Rebalance'], group='⑥ FVG', inline='fv5')
ifvgmitigationtype=input.string('Engulf', title='Imp.', options=['Engulf', 'Mitigate'], group='⑥ FVG', inline='fv5')
cefvg=input.bool(true, title='C.E. Line         ', group='⑥ FVG', inline='fv6')
celinetype=input.string(line.style_dashed, '', options=[line.style_dashed, line.style_dotted, line.style_solid], group='⑥ FVG', inline='fv6')
cetransparency=input.int(50, title='Transp.', group='⑥ FVG', inline='fv6')
extendfvgbox=input.bool(true, title='Extend Unmit.', group='⑥ FVG', inline='fv6')

BoxBorder=input.string(line.style_solid, title='Border            ', options=[line.style_dashed, line.style_dotted, line.style_solid], group='⑦ Box Style', inline='bx1', tooltip='FVG/VI/GAP boxes')
BorderTransparency=input.int(85, title='Transp.', minval=0, maxval=100, group='⑦ Box Style', inline='bx1')
HighlightBox=input.bool(true, title='Highlight         ', group='⑦ Box Style', inline='bx2', tooltip='Highlight on price touch')
Highlightboxtransparency=input.int(80, 'BG', group='⑦ Box Style', inline='bx2')
Highlightboxbordertransparency=input.int(67, 'Border', group='⑦ Box Style', inline='bx2')
plotBoxLabel=input.bool(true, title='Label             ', group='⑦ Box Style', inline='bx3')
BoxLabelSize=input.string(size.tiny, options=[size.huge, size.large, size.small, size.tiny, size.auto, size.normal], group='⑦ Box Style', inline='bx3')
BoxLabelColor=input.color(color.rgb(161, 163, 171), group='⑦ Box Style', inline='bx3')
labelhalign=input.string(text.align_center, '', options=[text.align_center, text.align_right, text.align_left], group='⑦ Box Style', inline='bx3')
labelvalign=input.string(text.align_center, '', options=[text.align_top, text.align_center, text.align_bottom], group='⑦ Box Style', inline='bx3')

filterMitBOX=input.bool(true, title='Mitigated Color   ', group='⑦ Box Style', inline='bx4')
mitBOXColor=input.color(color.new(color.gray, 92), group='⑦ Box Style', inline='bx4')
MitBoxLabelColor=input.color(color.rgb(161, 163, 171, 88), title='Lbl', group='⑦ Box Style', inline='bx4')

var bool kz_showAsian=input.bool(true, "Asian", group="⑱ Killzones", inline="kz1")
var color kz_asianColor=input.color(color.new(#2962ff, 90), "", group="⑱ Killzones", inline="kz1")
var int kz_asianStart=input.int(20, "Start", 0, 23, group="⑱ Killzones", inline="kz1", tooltip="NY 24h")
var int kz_asianEnd=input.int(0, "End", 0, 23, group="⑱ Killzones", inline="kz1")
var bool kz_showLondon=input.bool(true, "London", group="⑱ Killzones", inline="kz2")
var color kz_londonColor=input.color(color.new(#00bcd4, 90), "", group="⑱ Killzones", inline="kz2")
var int kz_londonStart=input.int(2, "Start", 0, 23, group="⑱ Killzones", inline="kz2")
var int kz_londonEnd=input.int(5, "End", 0, 23, group="⑱ Killzones", inline="kz2")
var bool kz_showNYAM=input.bool(true, "New York AM", group="⑱ Killzones", inline="kz3")
var color kz_nyamColor=input.color(color.new(#ff9800, 90), "", group="⑱ Killzones", inline="kz3")
var int kz_nyamStart=input.int(9, "Start", 0, 23, group="⑱ Killzones", inline="kz3")
var int kz_nyamStartM=input.int(30, ":", 0, 59, group="⑱ Killzones", inline="kz3")
var int kz_nyamEnd=input.int(12, "End", 0, 23, group="⑱ Killzones", inline="kz3")
var bool kz_showNYPM=input.bool(true, "New York PM", group="⑱ Killzones", inline="kz4")
var color kz_nypmColor=input.color(color.new(#e91e63, 90), "", group="⑱ Killzones", inline="kz4")
var int kz_nypmStart=input.int(13, "Start", 0, 23, group="⑱ Killzones", inline="kz4")
var int kz_nypmStartM=input.int(30, ":", 0, 59, group="⑱ Killzones", inline="kz4")
var int kz_nypmEnd=input.int(16, "End", 0, 23, group="⑱ Killzones", inline="kz4")
var bool kz_showSBAM=input.bool(false, "Silver Bullet AM", group="⑱ Killzones", inline="kz5")
var color kz_sbamColor=input.color(color.new(#c0ca33, 88), "", group="⑱ Killzones", inline="kz5")
var int kz_sbamStart=input.int(10, "Start", 0, 23, group="⑱ Killzones", inline="kz5")
var int kz_sbamEnd=input.int(11, "End", 0, 23, group="⑱ Killzones", inline="kz5")
var bool kz_showSBPM=input.bool(false, "Silver Bullet PM", group="⑱ Killzones", inline="kz6")
var color kz_sbpmColor=input.color(color.new(#c0ca33, 88), "", group="⑱ Killzones", inline="kz6")
var int kz_sbpmStart=input.int(14, "Start", 0, 23, group="⑱ Killzones", inline="kz6")
var int kz_sbpmEnd=input.int(15, "End", 0, 23, group="⑱ Killzones", inline="kz6")

var bool sh_showAsian=input.bool(true, "Asia H/L", group="⑲ Session Highs/Lows", inline="sh1")
var color sh_asianHColor=input.color(color.new(#ff9800, 20), "", group="⑲ Session Highs/Lows", inline="sh1")
var color sh_asianLColor=input.color(color.new(#ff9800, 20), "", group="⑲ Session Highs/Lows", inline="sh1")
var string sh_asianStyle=input.string("⎯⎯⎯", "", options=['⎯⎯⎯', '----', '····'], group="⑲ Session Highs/Lows", inline="sh1")
var bool sh_showLondon=input.bool(true, "London H/L", group="⑲ Session Highs/Lows", inline="sh2")
var color sh_londonHColor=input.color(color.new(#00bcd4, 20), "", group="⑲ Session Highs/Lows", inline="sh2")
var color sh_londonLColor=input.color(color.new(#00bcd4, 20), "", group="⑲ Session Highs/Lows", inline="sh2")
var string sh_londonStyle=input.string("⎯⎯⎯", "", options=['⎯⎯⎯', '----', '····'], group="⑲ Session Highs/Lows", inline="sh2")
var bool sh_showNYAM=input.bool(true, "NY AM H/L", group="⑲ Session Highs/Lows", inline="sh3")
var color sh_nyamHColor=input.color(color.new(#ef5350, 20), "", group="⑲ Session Highs/Lows", inline="sh3")
var color sh_nyamLColor=input.color(color.new(#ef5350, 20), "", group="⑲ Session Highs/Lows", inline="sh3")
var string sh_nyamStyle=input.string("⎯⎯⎯", "", options=['⎯⎯⎯', '----', '····'], group="⑲ Session Highs/Lows", inline="sh3")
var bool sh_showNYPre=input.bool(true, "NY Pre-AM H/L", group="⑲ Session Highs/Lows", inline="sh3a")
var color sh_nypreHColor=input.color(color.new(#ffeb3b, 20), "", group="⑲ Session Highs/Lows", inline="sh3a")
var color sh_nypreLColor=input.color(color.new(#ffeb3b, 20), "", group="⑲ Session Highs/Lows", inline="sh3a")
var string sh_nypreStyle=input.string("⎯⎯⎯", "", options=['⎯⎯⎯', '----', '····'], group="⑲ Session Highs/Lows", inline="sh3a")
var bool sh_showNYLunch=input.bool(true, "NY Lunch H/L", group="⑲ Session Highs/Lows", inline="sh3b")
var color sh_nylHColor=input.color(color.new(#ab47bc, 20), "", group="⑲ Session Highs/Lows", inline="sh3b")
var color sh_nylLColor=input.color(color.new(#ab47bc, 20), "", group="⑲ Session Highs/Lows", inline="sh3b")
var string sh_nylStyle=input.string("⎯⎯⎯", "", options=['⎯⎯⎯', '----', '····'], group="⑲ Session Highs/Lows", inline="sh3b")
var bool sh_showNYPM=input.bool(true, "NY PM H/L", group="⑲ Session Highs/Lows", inline="sh3c")
var color sh_nypmHColor=input.color(color.new(#4caf50, 20), "", group="⑲ Session Highs/Lows", inline="sh3c")
var color sh_nypmLColor=input.color(color.new(#4caf50, 20), "", group="⑲ Session Highs/Lows", inline="sh3c")
var string sh_nypmStyle=input.string("⎯⎯⎯", "", options=['⎯⎯⎯', '----', '····'], group="⑲ Session Highs/Lows", inline="sh3c")
var bool sh_showLabels=input.bool(true, "Show Labels", group="⑲ Session Highs/Lows", inline="sh4")
var int sh_lineWidth=input.int(1, "Width", 1, 4, group="⑲ Session Highs/Lows", inline="sh4")
var string sh_labelSize=input.string("Tiny", "Label Size", options=['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'Huge'], group="⑲ Session Highs/Lows", inline="sh4b")
var bool sh_showCurrent=input.bool(false, "Show Current Session H/L", group="⑲ Session Highs/Lows", tooltip="Show live session H/L.")
var int sh_lineExtend=input.int(50, "Line Extend Bars", 10, 200, group="⑲ Session Highs/Lows", inline="sh10")
var int sh_historyCount=input.int(5, "Sessions to Show", 1, 20, group="⑲ Session Highs/Lows", inline="sh11", tooltip="Sessions to show (1-20). Uses ⑱.")
var bool sh_showMit=input.bool(true, "Show Mitigated", group="⑲ Session Highs/Lows", inline="sh12")
var color sh_mitColor=input.color(color.new(color.gray, 60), "Line", group="⑲ Session Highs/Lows", inline="sh12")
var color sh_mitLblColor=input.color(color.new(color.gray, 70), "Lbl", group="⑲ Session Highs/Lows", inline="sh12")
var int sh_mitLineWidth=input.int(1, "Width", 1, 4, group="⑲ Session Highs/Lows", inline="sh12", tooltip="Mitigated styling.")
var string sh_mitLabelSize=input.string("Tiny", "Mit Label Size", options=['Auto', 'Tiny', 'Small', 'Normal', 'Large', 'Huge'], group="⑲ Session Highs/Lows", inline="sh12b")

var bool lq_showPDH=input.bool(true, "PDH / PDL", group="⑳ Liquidity Levels", inline="lq1")
var color lq_pdhColor=input.color(color.new(#26a69a, 20), "", group="⑳ Liquidity Levels", inline="lq1")
var color lq_pdlColor=input.color(color.new(#ef5350, 20), "", group="⑳ Liquidity Levels", inline="lq1")
var string lq_pdStyle=input.string("----", "", options=['⎯⎯⎯', '----', '····'], group="⑳ Liquidity Levels", inline="lq1")
var bool lq_showPWH=input.bool(true, "PWH / PWL", group="⑳ Liquidity Levels", inline="lq2")
var color lq_pwhColor=input.color(color.new(#26a69a, 10), "", group="⑳ Liquidity Levels", inline="lq2")
var color lq_pwlColor=input.color(color.new(#ef5350, 10), "", group="⑳ Liquidity Levels", inline="lq2")
var string lq_pwStyle=input.string("⎯⎯⎯", "", options=['⎯⎯⎯', '----', '····'], group="⑳ Liquidity Levels", inline="lq2")
var bool lq_showPMH=input.bool(false, "PMH / PML", group="⑳ Liquidity Levels", inline="lq3")
var color lq_pmhColor=input.color(color.new(#26a69a, 0), "", group="⑳ Liquidity Levels", inline="lq3")
var color lq_pmlColor=input.color(color.new(#ef5350, 0), "", group="⑳ Liquidity Levels", inline="lq3")
var string lq_pmStyle=input.string("⎯⎯⎯", "", options=['⎯⎯⎯', '----', '····'], group="⑳ Liquidity Levels", inline="lq3")
var bool lq_showLabels=input.bool(true, "Show Labels", group="⑳ Liquidity Levels", inline="lq4")
var int lq_lineWidth=input.int(1, "Width", 1, 4, group="⑳ Liquidity Levels", inline="lq4")

var bool buimpfvgtouch=false
var bool beimpfvgtouch=false
var bool bufvgtouch=false
var bool befvgtouch=false
var bool buvitouch=false
var bool bevitouch=false
var bool bugaptouch=false
var bool begaptouch=false
var bool buinvfvgtouch=false
var bool beinvfvgtouch=false

bool isbuinversefvg = false
bool isbeinversefvg = false

var int _fvg=2
var int _vi=3

var array<box> _bearBoxesFVG=array.new_box()
var array<box> _bullBoxesFVG=array.new_box()
var array<box> _gapsboxesbu=array.new_box()
var array<box> _gapsboxesbe=array.new_box()
var array<box> _bullishvi=array.new_box()
var array<box> _bearishvi=array.new_box()
var array<box> _bullishifvg=array.new_box()
var array<box> _bearishifvg=array.new_box()
var array<line> _bufvgce=array.new_line()
var array<line> _befvgce=array.new_line()
var array<box> bearInvFVG=array.new_box()
var array<box> bullInvFVG=array.new_box()
var array<line> buinvfvgce=array.new_line()
var array<line> beinvfvgce=array.new_line()
var array<line> bugapce=array.new_line()
var array<line> begapce=array.new_line()

_controlBox2(_boxes, _high, _low) =>
	if array.size(_boxes) > 0
		for i = array.size(_boxes) - 1 to 0 by 1
			_box = array.get(_boxes, i)
			_boxLow = box.get_bottom(_box)
			_boxHigh = box.get_top(_box)
			_boxRight = box.get_right(_box)
			if extendallvis
				box.set_right(_box, bar_index + 1)

isBuVItype1(index) =>
	open[index] > close[index + 1] and low[index] <= high[index + 1] and close[index] > open[index] and close[index + 1] > open[index + 1]

isBeVItype1(index) =>
	open[index] < close[index + 1] and high[index] >= low[index + 1] and close[index] < open[index] and close[index + 1] < open[index + 1]

isBuVItype2(index) =>
	open[index] < close[index + 1] and close[index] > open[index] and close[index + 1] > open[index + 1] and high[index] >= low[index + 1]

isBeVItype2(index) =>
	open[index] > close[index + 1] and close[index] < open[index] and close[index + 1] < open[index + 1] and low[index] <= high[index + 1]

isBuVItype3(index) =>
	open[index] != close[index + 1] and close[index] > open[index] and close[index + 1] < open[index + 1] and high[index] >= low[index + 1] and low[index] <= high[index + 1]

isBeVItype3(index) =>
	open[index] != close[index + 1] and close[index] < open[index] and close[index + 1] > open[index + 1] and low[index] <= high[index + 1] and high[index] >= low[index + 1]

if isBuVItype1(0) and (classicvi or advancedvi) and ENABLE_IMBALANCES
	box _bullboxVI = box.new(left = bar_index - 1, top = open, right = bar_index + 1, bottom = close[1], bgcolor = bullimbalance, border_style = BoxBorder, border_color = color.new(bullimbalance, BorderTransparency), text = plotBoxLabel ? 'VI+' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	if array.size(_bullishvi) > viMaxBoxSet
		box.delete(array.shift(_bullishvi))
	array.push(_bullishvi, _bullboxVI)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("VI+", open, close[1]), alert.freq_once_per_bar_close)

if isBeVItype1(0) and (classicvi or advancedvi) and ENABLE_IMBALANCES
	box _bearboxVI = box.new(left = bar_index - 1, top = close[1], right = bar_index + 1, bottom = open, bgcolor = bearimbalance, border_style = BoxBorder, border_color = color.new(bearimbalance, BorderTransparency), text = plotBoxLabel ? 'VI-' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	if array.size(_bearishvi) > viMaxBoxSet
		box.delete(array.shift(_bearishvi))
	array.push(_bearishvi, _bearboxVI)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("VI-", close[1], open), alert.freq_once_per_bar_close)

if isBuVItype2(0) and advancedvi and ENABLE_IMBALANCES
	box _bullboxVI = box.new(left = bar_index - 1, top = close[1], right = bar_index + 1, bottom = open, bgcolor = bullimbalance, border_style = BoxBorder, border_color = color.new(bullimbalance, BorderTransparency), text = plotBoxLabel ? 'VI+' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	if array.size(_bullishvi) > viMaxBoxSet
		box.delete(array.shift(_bullishvi))
	array.push(_bullishvi, _bullboxVI)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("VI+", close[1], open), alert.freq_once_per_bar_close)

if isBeVItype2(0) and advancedvi and ENABLE_IMBALANCES
	box _bearboxVI = box.new(left = bar_index - 1, top = open, right = bar_index + 1, bottom = close[1], bgcolor = bearimbalance, border_style = BoxBorder, border_color = color.new(bearimbalance, BorderTransparency), text = plotBoxLabel ? 'VI-' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	if array.size(_bearishvi) > viMaxBoxSet
		box.delete(array.shift(_bearishvi))
	array.push(_bearishvi, _bearboxVI)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("VI-", open, close[1]), alert.freq_once_per_bar_close)

if isBuVItype3(0) and advancedvi and ENABLE_IMBALANCES
	box _bullboxVI = box.new(left = bar_index - 1, top = math.max(open, close[1]), right = bar_index + 1, bottom = math.min(open, close[1]), bgcolor = bullimbalance, border_style = BoxBorder, border_color = color.new(bullimbalance, BorderTransparency), text = plotBoxLabel ? 'VI+' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	if array.size(_bullishvi) > viMaxBoxSet
		box.delete(array.shift(_bullishvi))
	array.push(_bullishvi, _bullboxVI)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("VI+", math.max(open, close[1]), math.min(open, close[1])), alert.freq_once_per_bar_close)

if isBeVItype3(0) and advancedvi and ENABLE_IMBALANCES
	box _bearboxVI = box.new(left = bar_index - 1, top = math.min(open, close[1]), right = bar_index + 1, bottom = math.max(open, close[1]), bgcolor = bearimbalance, border_style = BoxBorder, border_color = color.new(bearimbalance, BorderTransparency), text = plotBoxLabel ? 'VI-' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	if array.size(_bearishvi) > viMaxBoxSet
		box.delete(array.shift(_bearishvi))
	array.push(_bearishvi, _bearboxVI)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("VI-", math.min(open, close[1]), math.max(open, close[1])), alert.freq_once_per_bar_close)

if extendallvis
	_controlBox2(_bullishvi, high, low)
	_controlBox2(_bearishvi, high, low)

if (high[1] < low or low[1] > high) and truegap and ENABLE_IMBALANCES
	box _gapsbu = na
	box _gapsbe = na
	line bugapceline = na
	line begapceline = na
	if high[1] < low
		_gapsbu := box.new(left = bar_index - 1, top = low, right = bar_index + 1, bottom = high[1], bgcolor = gapcolor, border_color = color.new(gapcolor, BorderTransparency), text = plotBoxLabel ? 'GAP+' : na, border_style = BoxBorder, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
		bugapceline := cegap ? line.new(bar_index - 1, math.avg(low, high[1]), bar_index, math.avg(low, high[1]), style = celinetype, color = color.new(gapcolor, cetransparency)) : na
		if wh_enable and wh_formations and barstate.isconfirmed
			alert(_wh_json("GAP+", low, high[1]), alert.freq_once_per_bar_close)
		bugapceline
	else if low[1] > high
		_gapsbe := box.new(left = bar_index - 1, top = low[1], right = bar_index + 1, bottom = high, bgcolor = gapcolor, border_color = color.new(gapcolor, BorderTransparency), text = plotBoxLabel ? 'GAP-' : na, border_style = BoxBorder, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
		begapceline := cegap ? line.new(bar_index - 1, math.avg(low[1], high), bar_index, math.avg(low[1], high), style = celinetype, color = color.new(gapcolor, cetransparency)) : na
		if wh_enable and wh_formations and barstate.isconfirmed
			alert(_wh_json("GAP-", low[1], high), alert.freq_once_per_bar_close)
		begapceline
	if array.size(_gapsboxesbu) > gapsMaxBoxSet and array.size(bugapce) > gapsMaxBoxSet
		box.delete(array.shift(_gapsboxesbu))
		line.delete(array.shift(bugapce))
	array.push(_gapsboxesbu, _gapsbu)
	array.push(bugapce, bugapceline)
	if array.size(_gapsboxesbe) > gapsMaxBoxSet and array.size(begapce) > gapsMaxBoxSet
		box.delete(array.shift(_gapsboxesbe))
		line.delete(array.shift(begapce))
	array.push(_gapsboxesbe, _gapsbe)
	array.push(begapce, begapceline)
else if (high[1] < low or low[1] > high) and gapwithimb and ENABLE_IMBALANCES
	box _gapsbu = na
	box _gapsbe = na
	line bugapceline = na
	line begapceline = na
	if high[1] < low
		_gapsbu := box.new(left = bar_index - 1, top = open, right = bar_index + 1, bottom = close[1], bgcolor = gapcolor, border_color = color.new(gapcolor, BorderTransparency), text = plotBoxLabel ? 'GAP+' : na, border_style = BoxBorder, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
		bugapceline := cegap ? line.new(bar_index - 1, math.avg(open, close[1]), bar_index, math.avg(open, close[1]), style = celinetype, color = color.new(gapcolor, cetransparency)) : na
		bugapceline
	else if low[1] > high
		_gapsbe := box.new(left = bar_index - 1, top = close[1], right = bar_index + 1, bottom = open, bgcolor = gapcolor, border_color = color.new(gapcolor, BorderTransparency), text = plotBoxLabel ? 'GAP-' : na, border_style = BoxBorder, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
		begapceline := cegap ? line.new(bar_index - 1, math.avg(close[1], open), bar_index, math.avg(close[1], open), style = celinetype, color = color.new(gapcolor, cetransparency)) : na
		begapceline
	if array.size(_gapsboxesbu) > gapsMaxBoxSet and array.size(bugapce) > gapsMaxBoxSet
		box.delete(array.shift(_gapsboxesbu))
		line.delete(array.shift(bugapce))
	array.push(_gapsboxesbu, _gapsbu)
	array.push(bugapce, bugapceline)
	if array.size(_gapsboxesbe) > gapsMaxBoxSet and array.size(begapce) > gapsMaxBoxSet
		box.delete(array.shift(_gapsboxesbe))
		line.delete(array.shift(begapce))
	array.push(_gapsboxesbe, _gapsbe)
	array.push(begapce, begapceline)

isFvgUp(index) =>
	low[index] > high[index + 2] and low[index + 1] <= high[index + 2] and high[index + 1] >= low[index]

isFvgDown(index) =>
	high[index] < low[index + 2] and high[index] >= low[index + 1] and high[index + 1] >= low[index + 2]

if isFvgUp(0) and not liquidityvoidmode and ENABLE_IMBALANCES
	box _bullboxFVG = na
	line _buline = na
	if plotFVG or Inversefvgmode
		color _fvgBg = (not plotFVG and Inversefvgmode) ? color.new(fvgBullColor, 100) : fvgBullColor
		color _fvgBdr = (not plotFVG and Inversefvgmode) ? color.new(fvgBullColor, 100) : color.new(fvgBullColor, BorderTransparency)
		color _fvgTxt = (not plotFVG and Inversefvgmode) ? color.new(BoxLabelColor, 100) : BoxLabelColor
		color _fvgCe = (not plotFVG and Inversefvgmode) ? color.new(fvgBullColor, 100) : color.new(fvgBullColor, cetransparency)
		_bullboxFVG := box.new(left = bar_index - 2, top = low[0], right = bar_index, bottom = high[2], bgcolor = _fvgBg, border_color = _fvgBdr, border_style = BoxBorder, border_width = 1, text = plotBoxLabel ? 'FVG+' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = _fvgTxt)
		_buline := cefvg ? line.new(bar_index - 2, math.avg(low, high[2]), bar_index, math.avg(low, high[2]), style = celinetype, color = _fvgCe) : na
		_buline
	if array.size(_bullBoxesFVG) > fvgMaxBoxSet and array.size(_bufvgce) > fvgMaxBoxSet
		box.delete(array.shift(_bullBoxesFVG))
		line.delete(array.shift(_bufvgce))
	array.push(_bullBoxesFVG, _bullboxFVG)
	array.push(_bufvgce, _buline)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("FVG+", low, high[2]), alert.freq_once_per_bar_close)

if isFvgDown(0) and not liquidityvoidmode and ENABLE_IMBALANCES
	box _bearboxFVG = na
	line _beline = na
	if plotFVG or Inversefvgmode
		color _fvgBeBg = (not plotFVG and Inversefvgmode) ? color.new(fvgBearColor, 100) : fvgBearColor
		color _fvgBeBdr = (not plotFVG and Inversefvgmode) ? color.new(fvgBearColor, 100) : color.new(fvgBearColor, BorderTransparency)
		color _fvgBeTxt = (not plotFVG and Inversefvgmode) ? color.new(BoxLabelColor, 100) : BoxLabelColor
		color _fvgBeCe = (not plotFVG and Inversefvgmode) ? color.new(fvgBearColor, 100) : color.new(fvgBearColor, cetransparency)
		_bearboxFVG := box.new(left = bar_index - 2, top = low[2], right = bar_index, bottom = high[0], bgcolor = _fvgBeBg, border_color = _fvgBeBdr, border_style = BoxBorder, border_width = 1, text = plotBoxLabel ? 'FVG-' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = _fvgBeTxt)
		_beline := cefvg ? line.new(bar_index - 2, math.avg(low[2], high), bar_index, math.avg(low[2], high), style = celinetype, color = _fvgBeCe) : na
		_beline
	if array.size(_bearBoxesFVG) > fvgMaxBoxSet and array.size(_befvgce) > fvgMaxBoxSet
		box.delete(array.shift(_bearBoxesFVG))
		line.delete(array.shift(_befvgce))
	array.push(_bearBoxesFVG, _bearboxFVG)
	array.push(_befvgce, _beline)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("FVG-", low[2], high), alert.freq_once_per_bar_close)

bool bulv = false
bool belv = false

if isFvgUp(0) and isFvgUp(1) and (liquidityvoidmode or Inversefvgmode) and array.size(_bullBoxesFVG) > 0 and not plotFVG
	bulv := true
	x = array.size(_bullBoxesFVG) - 1
	_box = array.get(_bullBoxesFVG, x)
	tempboxlow = box.get_bottom(_box)
	tempboxleft = box.get_left(_box)
	box.delete(array.pop(_bullBoxesFVG))
	line.delete(array.pop(_bufvgce))
	box _bullboxFVG = box.new(left = tempboxleft, top = low[0], right = bar_index, bottom = tempboxlow, bgcolor = fvgBullColor, border_color = color.new(fvgBullColor, BorderTransparency), border_width = 1, text = plotBoxLabel ? 'LV+' : na, border_style = BoxBorder, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	line _buline = cefvg ? line.new(tempboxleft, math.avg(low, tempboxlow), bar_index, math.avg(low, tempboxlow), style = celinetype, color = color.new(fvgBullColor, cetransparency)) : na
	if array.size(_bullBoxesFVG) > fvgMaxBoxSet and array.size(_bufvgce) > fvgMaxBoxSet
		box.delete(array.shift(_bullBoxesFVG))
		line.delete(array.shift(_bufvgce))
	array.push(_bullBoxesFVG, _bullboxFVG)
	array.push(_bufvgce, _buline)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("LV+", low, tempboxlow), alert.freq_once_per_bar_close)
else if isFvgUp(0) and not isFvgUp(1) and (liquidityvoidmode or Inversefvgmode) and not plotFVG
	box _bullboxFVG = box.new(left = bar_index - 2, top = low[0], right = bar_index, bottom = high[2], bgcolor = fvgBullColor, border_color = color.new(fvgBullColor, BorderTransparency), border_width = 1, text = plotBoxLabel ? 'FVG+' : na, border_style = BoxBorder, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	line _buline = cefvg ? line.new(bar_index - 2, math.avg(low, high[2]), bar_index, math.avg(low, high[2]), style = celinetype, color = color.new(fvgBullColor, cetransparency)) : na
	if array.size(_bullBoxesFVG) > fvgMaxBoxSet and array.size(_bufvgce) > fvgMaxBoxSet
		box.delete(array.shift(_bullBoxesFVG))
		line.delete(array.shift(_bufvgce))
	array.push(_bullBoxesFVG, _bullboxFVG)
	array.push(_bufvgce, _buline)

if isFvgDown(0) and isFvgDown(1) and (liquidityvoidmode or Inversefvgmode) and array.size(_bearBoxesFVG) > 0 and not plotFVG
	belv := true
	x = array.size(_bearBoxesFVG) - 1
	_box = array.get(_bearBoxesFVG, x)
	tempboxhigh = box.get_top(_box)
	tempboxleft = box.get_left(_box)
	box.delete(array.pop(_bearBoxesFVG))
	line.delete(array.pop(_befvgce))
	box _bearboxFVG = box.new(left = tempboxleft, top = tempboxhigh, right = bar_index, bottom = high[0], bgcolor = fvgBearColor, border_color = color.new(fvgBearColor, BorderTransparency), border_width = 1, text = plotBoxLabel ? 'LV-' : na, border_style = BoxBorder, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	line _beline = cefvg ? line.new(tempboxleft, math.avg(tempboxhigh, high), bar_index, math.avg(tempboxhigh, high), style = celinetype, color = color.new(fvgBearColor, cetransparency)) : na
	if array.size(_bearBoxesFVG) > fvgMaxBoxSet and array.size(_befvgce) > fvgMaxBoxSet
		box.delete(array.shift(_bearBoxesFVG))
		line.delete(array.shift(_befvgce))
	array.push(_bearBoxesFVG, _bearboxFVG)
	array.push(_befvgce, _beline)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("LV-", tempboxhigh, high), alert.freq_once_per_bar_close)
else if isFvgDown(0) and not isFvgDown(1) and (liquidityvoidmode or Inversefvgmode) and not plotFVG
	box _bearboxFVG = box.new(left = bar_index - 2, top = low[2], right = bar_index, bottom = high[0], bgcolor = fvgBearColor, border_color = color.new(fvgBearColor, BorderTransparency), border_width = 1, text = plotBoxLabel ? 'FVG-' : na, border_style = BoxBorder, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	line _beline = cefvg ? line.new(bar_index - 2, math.avg(low[2], high), bar_index, math.avg(low[2], high), style = celinetype, color = color.new(fvgBearColor, cetransparency)) : na
	if array.size(_bearBoxesFVG) > fvgMaxBoxSet and array.size(_befvgce) > fvgMaxBoxSet
		box.delete(array.shift(_bearBoxesFVG))
		line.delete(array.shift(_befvgce))
	array.push(_bearBoxesFVG, _bearboxFVG)
	array.push(_befvgce, _beline)

isBuIFvg(index) =>
	high[index] > high[index + 2] and low[index + 2] < low[index] and low[index] <= high[index + 2] and high[index + 2] - math.max(open[index + 2], close[index + 2]) > (math.max(open[index + 2], close[index + 2]) - math.min(open[index + 2], close[index + 2])) / 2 and math.min(open[index], close[index]) - low[index] > (math.max(open[index], close[index]) - math.min(open[index], close[index])) / 2 and low[index] > low[index + 1] and (high[index + 2] + math.max(open[index + 2], close[index + 2])) / 2 < (math.min(open[index], close[index]) + low[index]) / 2 and high[index] > high[index + 1] and close[index + 1] > open[index + 1]

isBeIFvg(index) =>
	low[index] < low[index + 2] and high[index + 2] > high[index] and high[index] >= low[index + 2] and math.min(open[index + 2], close[index + 2]) - low[index + 2] > (math.max(open[index + 2], close[index + 2]) - math.min(open[index + 2], close[index + 2])) / 2 and high[index] - math.max(open[index], close[index]) > (math.max(open[index], close[index]) - math.min(open[index], close[index])) / 2 and high[index] < high[index + 1] and (math.min(open[index + 2], close[index + 2]) + low[index + 2]) / 2 > (high[index] + math.max(open[index], close[index])) / 2 and low[index] < low[index + 1] and close[index + 1] < open[index + 1]

if isBuIFvg(0) and showifvg and ENABLE_IMBALANCES
	box _bullboxifvg = box.new(left = bar_index - 2, top = (math.min(open, close) + low) / 2, right = bar_index + 1, bottom = (high[2] + math.max(open[2], close[2])) / 2, bgcolor = ifvgBullColor, border_style = BoxBorder, border_color = color.new(ifvgBullColor, BorderTransparency), text = plotBoxLabel ? 'Imp.FVG+' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	if array.size(_bullishifvg) > fvgMaxBoxSet
		box.delete(array.shift(_bullishifvg))
	array.push(_bullishifvg, _bullboxifvg)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("I.FVG+", (math.min(open, close) + low) / 2, (high[2] + math.max(open[2], close[2])) / 2), alert.freq_once_per_bar_close)

if isBeIFvg(0) and showifvg and ENABLE_IMBALANCES
	box _bearboxifvg = box.new(left = bar_index - 2, top = (math.min(open[2], close[2]) + low[2]) / 2, right = bar_index + 1, bottom = (math.max(open, close) + high) / 2, bgcolor = ifvgBearColor, border_style = BoxBorder, border_color = color.new(ifvgBearColor, BorderTransparency), text = plotBoxLabel ? 'Imp.FVG-' : na, text_halign = labelhalign, text_valign = labelvalign, text_size = BoxLabelSize, text_color = BoxLabelColor)
	if array.size(_bearishifvg) > fvgMaxBoxSet
		box.delete(array.shift(_bearishifvg))
	array.push(_bearishifvg, _bearboxifvg)
	if wh_enable and wh_formations and barstate.isconfirmed
		alert(_wh_json("I.FVG-", (math.min(open[2], close[2]) + low[2]) / 2, (math.max(open, close) + high) / 2), alert.freq_once_per_bar_close)

_applyMitStyle(_bx, _ln, bool _hasLine) =>
	box.set_bgcolor(_bx, mitBOXColor)
	box.set_border_color(_bx, mitBOXColor)
	box.set_text_color(_bx, MitBoxLabelColor)
	if _hasLine
		line.set_color(_ln, mitBOXColor)

_applyHighlight(_bx, color _baseColor) =>
	box.set_bgcolor(_bx, color.new(_baseColor, Highlightboxtransparency))
	box.set_border_color(_bx, color.new(_baseColor, Highlightboxbordertransparency))

if ENABLE_IMBALANCES and array.size(_bullishifvg) > 0 and extendfvgbox
	for i = array.size(_bullishifvg) - 1 to 0 by 1
		_box = array.get(_bullishifvg, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if bar_index == _boxRight
			if barstate.isconfirmed
				if ifvgmitigationtype == 'Engulf'
					if close >= _boxLow and open >= _boxLow
						box.set_right(_box, bar_index + 1)
					else if (close < _boxLow or open < _boxLow) and filterMitBOX
						_applyMitStyle(_box, line(na), false)
				else if ifvgmitigationtype == 'Mitigate'
					if low >= _boxHigh
						box.set_right(_box, bar_index + 1)
					else if low < _boxHigh and filterMitBOX
						_applyMitStyle(_box, line(na), false)
			_boxRight := box.get_right(_box)
			if bar_index == _boxRight and ifvgmitigationtype == 'Engulf' and HighlightBox
				if close >= _boxLow and low < _boxHigh
					_applyHighlight(_box, ifvgBullColor)
					buimpfvgtouch := true
					if wh_enable and wh_mitigations
						alert(_wh_json("I.FVG+ Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
					buimpfvgtouch

if ENABLE_IMBALANCES and array.size(_bearishifvg) > 0 and extendfvgbox
	for i = array.size(_bearishifvg) - 1 to 0 by 1
		_box = array.get(_bearishifvg, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if bar_index == _boxRight
			if barstate.isconfirmed
				if ifvgmitigationtype == 'Engulf'
					if close <= _boxHigh and open <= _boxHigh
						box.set_right(_box, bar_index + 1)
					else if (close > _boxHigh or open > _boxHigh) and filterMitBOX
						_applyMitStyle(_box, line(na), false)
				else if ifvgmitigationtype == 'Mitigate'
					if high <= _boxLow
						box.set_right(_box, bar_index + 1)
					else if high > _boxLow and filterMitBOX
						_applyMitStyle(_box, line(na), false)
			_boxRight := box.get_right(_box)
			if bar_index == _boxRight and ifvgmitigationtype == 'Engulf' and HighlightBox
				if close <= _boxHigh and high > _boxLow
					_applyHighlight(_box, ifvgBearColor)
					beimpfvgtouch := true
					if wh_enable and wh_mitigations
						alert(_wh_json("I.FVG- Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
					beimpfvgtouch

if ENABLE_IMBALANCES and array.size(_bullBoxesFVG) > 0 and array.size(_bufvgce) > 0
	for i = array.size(_bullBoxesFVG) - 1 to 0 by 1
		_box = array.get(_bullBoxesFVG, i)
		_line = array.get(_bufvgce, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if bar_index == _boxRight
			if barstate.isconfirmed and extendfvgbox
				if fvgmitigationtype == 'Engulf'
					if close >= _boxLow
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if close < _boxLow and Inversefvgmode
						box beifvgbox = box.copy(_box)
						array.push(bearInvFVG, beifvgbox)
						line beifvgceline = line.copy(_line)
						array.push(beinvfvgce, beifvgceline)
						box.delete(_box)
						line.delete(_line)
						isbeinversefvg := true
						if wh_enable and wh_formations
							alert(_wh_json("Inverse.FVG-", _boxHigh, _boxLow), alert.freq_once_per_bar_close)
						isbeinversefvg
					else if close < _boxLow and filterMitBOX
						_applyMitStyle(_box, _line, true)
				else if fvgmitigationtype == 'Mitigate'
					if low >= _boxHigh
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if low < _boxHigh and filterMitBOX
						_applyMitStyle(_box, _line, true)
				else if fvgmitigationtype == 'Rebalance'
					if low >= _boxHigh
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if low < _boxHigh and low > _boxLow
						box.set_top(_box, low)
						box.set_right(_box, bar_index + 1)
						line.set_y1(_line, (low + _boxLow) / 2)
						line.set_y2(_line, (low + _boxLow) / 2)
						line.set_x2(_line, bar_index + 1)
					else if low <= _boxLow and filterMitBOX
						_applyMitStyle(_box, _line, true)
			_boxLow := box.get_bottom(_box)
			_boxHigh := box.get_top(_box)
			_boxRight := box.get_right(_box)
			if bar_index == _boxRight and extendfvgbox and HighlightBox
				if fvgmitigationtype == 'Engulf'
					if close >= _boxLow and low < _boxHigh
						_applyHighlight(_box, fvgBullColor)
						bufvgtouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("FVG+ Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						bufvgtouch
				else if fvgmitigationtype == 'Rebalance'
					if low < _boxHigh and low > _boxLow
						_applyHighlight(_box, fvgBullColor)
						bufvgtouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("FVG+ Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						bufvgtouch

if ENABLE_IMBALANCES and array.size(_bearBoxesFVG) > 0 and array.size(_befvgce) > 0
	for i = array.size(_bearBoxesFVG) - 1 to 0 by 1
		_box = array.get(_bearBoxesFVG, i)
		_line = array.get(_befvgce, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if bar_index == _boxRight
			if barstate.isconfirmed and extendfvgbox
				if fvgmitigationtype == 'Engulf'
					if close <= _boxHigh
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if close > _boxHigh and Inversefvgmode
						box buifvgbox = box.copy(_box)
						array.push(bullInvFVG, buifvgbox)
						line buifvgceline = line.copy(_line)
						array.push(buinvfvgce, buifvgceline)
						box.delete(_box)
						line.delete(_line)
						isbuinversefvg := true
						if wh_enable and wh_formations
							alert(_wh_json("Inverse.FVG+", _boxHigh, _boxLow), alert.freq_once_per_bar_close)
						isbuinversefvg
					else if close > _boxHigh and filterMitBOX
						_applyMitStyle(_box, _line, true)
				else if fvgmitigationtype == 'Mitigate'
					if high <= _boxLow
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if high > _boxLow and filterMitBOX
						_applyMitStyle(_box, _line, true)
				else if fvgmitigationtype == 'Rebalance'
					if high <= _boxLow
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if high > _boxLow and high < _boxHigh
						box.set_bottom(_box, high)
						box.set_right(_box, bar_index + 1)
						line.set_y1(_line, (high + _boxHigh) / 2)
						line.set_y2(_line, (high + _boxHigh) / 2)
						line.set_x2(_line, bar_index + 1)
					else if high >= _boxHigh and filterMitBOX
						_applyMitStyle(_box, _line, true)
			_boxLow := box.get_bottom(_box)
			_boxHigh := box.get_top(_box)
			_boxRight := box.get_right(_box)
			if bar_index == _boxRight and extendfvgbox and HighlightBox
				if fvgmitigationtype == 'Engulf'
					if close <= _boxHigh and high > _boxLow
						_applyHighlight(_box, fvgBearColor)
						befvgtouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("FVG- Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						befvgtouch
				else if fvgmitigationtype == 'Rebalance'
					if high > _boxLow and high < _boxHigh
						_applyHighlight(_box, fvgBearColor)
						befvgtouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("FVG- Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						befvgtouch

if ENABLE_IMBALANCES and array.size(bullInvFVG) > 0 and fvgmitigationtype == 'Engulf' and Inversefvgmode
	for i = array.size(bullInvFVG) - 1 to 0 by 1
		_box = array.get(bullInvFVG, i)
		_line = array.get(buinvfvgce, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if barstate.isconfirmed
			box.set_bgcolor(_box, buinvfvgcolor)
			if plotBoxLabel
				box.set_text(_box, 'I.FVG+')
				box.set_text_halign(_box, labelhalign)
				box.set_text_valign(_box, labelvalign)
				box.set_text_size(_box, BoxLabelSize)
				box.set_text_color(_box, BoxLabelColor)
			box.set_border_color(_box, color.new(buinvfvgcolor, BorderTransparency))
			line.set_color(_line, color.new(buinvfvgcolor, cetransparency))
			line.set_style(_line, celinetype)
			if close >= _boxLow and bar_index == _boxRight
				box.set_right(_box, bar_index + 1)
				line.set_x2(_line, bar_index + 1)
			else if close < _boxLow
				box.delete(_box)
				line.delete(_line)
		_boxRight := box.get_right(_box)
		if extendfvgbox and HighlightBox and bar_index == _boxRight
			if close >= _boxLow and low < _boxHigh
				_applyHighlight(_box, buinvfvgcolor)
				buinvfvgtouch := true
				if wh_enable and wh_mitigations
					alert(_wh_json("Inv.FVG+ Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
				buinvfvgtouch

if ENABLE_IMBALANCES and array.size(bearInvFVG) > 0 and fvgmitigationtype == 'Engulf' and Inversefvgmode
	for i = array.size(bearInvFVG) - 1 to 0 by 1
		_box = array.get(bearInvFVG, i)
		_line = array.get(beinvfvgce, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if barstate.isconfirmed
			box.set_bgcolor(_box, beinvfvgcolor)
			if plotBoxLabel
				box.set_text(_box, 'I.FVG-')
				box.set_text_halign(_box, labelhalign)
				box.set_text_valign(_box, labelvalign)
				box.set_text_size(_box, BoxLabelSize)
				box.set_text_color(_box, BoxLabelColor)
			box.set_border_color(_box, color.new(beinvfvgcolor, BorderTransparency))
			line.set_color(_line, color.new(beinvfvgcolor, cetransparency))
			line.set_style(_line, celinetype)
			if close <= _boxHigh and bar_index == _boxRight
				box.set_right(_box, bar_index + 1)
				line.set_x2(_line, bar_index + 1)
			else if close > _boxHigh
				box.delete(_box)
				line.delete(_line)
		_boxRight := box.get_right(_box)
		if extendfvgbox and HighlightBox and bar_index == _boxRight
			if close <= _boxHigh and high > _boxLow
				_applyHighlight(_box, beinvfvgcolor)
				beinvfvgtouch := true
				if wh_enable and wh_mitigations
					alert(_wh_json("Inv.FVG- Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
				beinvfvgtouch

if array.size(bullInvFVG) > invfvgMaxBoxSet
	box.delete(array.shift(bullInvFVG))
if array.size(bearInvFVG) > invfvgMaxBoxSet
	box.delete(array.shift(bearInvFVG))
if array.size(buinvfvgce) > invfvgMaxBoxSet
	line.delete(array.shift(buinvfvgce))
if array.size(beinvfvgce) > invfvgMaxBoxSet
	line.delete(array.shift(beinvfvgce))

if ENABLE_IMBALANCES and array.size(_bullishvi) > 0 and extendvibox
	for i = array.size(_bullishvi) - 1 to 0 by 1
		_box = array.get(_bullishvi, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if bar_index == _boxRight
			if barstate.isconfirmed
				if vimitigationtype == 'Engulf'
					if close >= _boxLow
						box.set_right(_box, bar_index + 1)
					else if close < _boxLow and filterMitBOX
						_applyMitStyle(_box, line(na), false)
				else if vimitigationtype == 'Mitigate'
					if low > _boxHigh
						box.set_right(_box, bar_index + 1)
					else if low <= _boxHigh and filterMitBOX
						_applyMitStyle(_box, line(na), false)
						buvitouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("VI+ Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						buvitouch
			_boxRight := box.get_right(_box)
			if bar_index == _boxRight and vimitigationtype == 'Engulf' and HighlightBox
				if close >= _boxLow and low < _boxHigh
					_applyHighlight(_box, bullimbalance)
					buvitouch := true
					if wh_enable and wh_mitigations
						alert(_wh_json("VI+ Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
					buvitouch

if ENABLE_IMBALANCES and array.size(_bearishvi) > 0 and extendvibox
	for i = array.size(_bearishvi) - 1 to 0 by 1
		_box = array.get(_bearishvi, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if bar_index == _boxRight
			if barstate.isconfirmed
				if vimitigationtype == 'Engulf'
					if close <= _boxHigh
						box.set_right(_box, bar_index + 1)
					else if close > _boxHigh and filterMitBOX
						_applyMitStyle(_box, line(na), false)
				else if vimitigationtype == 'Mitigate'
					if high < _boxHigh
						box.set_right(_box, bar_index + 1)
					else if high >= _boxHigh and filterMitBOX
						_applyMitStyle(_box, line(na), false)
						bevitouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("VI- Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						bevitouch
			_boxRight := box.get_right(_box)
			if bar_index == _boxRight and vimitigationtype == 'Engulf' and HighlightBox
				if close <= _boxHigh and high > _boxLow
					_applyHighlight(_box, bearimbalance)
					bevitouch := true
					if wh_enable and wh_mitigations
						alert(_wh_json("VI- Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
					bevitouch

if ENABLE_IMBALANCES and array.size(_gapsboxesbu) > 0 and array.size(bugapce) > 0 and extendgapbox
	for i = array.size(_gapsboxesbu) - 1 to 0 by 1
		_box = array.get(_gapsboxesbu, i)
		_line = array.get(bugapce, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if bar_index == _boxRight
			if barstate.isconfirmed
				if gapmitigationtype == 'Engulf'
					if close >= _boxLow and open >= _boxLow
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if (close < _boxLow or open < _boxLow) and filterMitBOX
						_applyMitStyle(_box, _line, true)
				else if gapmitigationtype == 'Rebalance'
					if low >= _boxHigh
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if low < _boxHigh and low > _boxLow
						box.set_top(_box, low)
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
						line.set_y1(_line, (low + _boxLow) / 2)
						line.set_y2(_line, (low + _boxLow) / 2)
					else if low <= _boxLow and filterMitBOX
						_applyMitStyle(_box, _line, true)
			_boxLow := box.get_bottom(_box)
			_boxHigh := box.get_top(_box)
			_boxRight := box.get_right(_box)
			if bar_index == _boxRight and HighlightBox
				if gapmitigationtype == 'Engulf'
					if close >= _boxLow and open >= _boxLow and low < _boxHigh
						_applyHighlight(_box, gapcolor)
						bugaptouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("GAP+ Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						bugaptouch
				else if gapmitigationtype == 'Rebalance'
					if low > _boxLow and low < _boxHigh
						_applyHighlight(_box, gapcolor)
						bugaptouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("GAP+ Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						bugaptouch

if ENABLE_IMBALANCES and array.size(_gapsboxesbe) > 0 and array.size(begapce) > 0 and extendgapbox
	for i = array.size(_gapsboxesbe) - 1 to 0 by 1
		_box = array.get(_gapsboxesbe, i)
		_line = array.get(begapce, i)
		_boxLow = box.get_bottom(_box)
		_boxHigh = box.get_top(_box)
		_boxRight = box.get_right(_box)
		if bar_index == _boxRight
			if barstate.isconfirmed
				if gapmitigationtype == 'Engulf'
					if close <= _boxHigh and open <= _boxHigh
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if (close > _boxHigh or open > _boxHigh) and filterMitBOX
						_applyMitStyle(_box, _line, true)
				else if gapmitigationtype == 'Rebalance'
					if high <= _boxLow
						box.set_right(_box, bar_index + 1)
						line.set_x2(_line, bar_index + 1)
					else if high > _boxLow and high < _boxHigh
						box.set_bottom(_box, high)
						box.set_right(_box, bar_index + 1)
						line.set_y1(_line, (high + _boxHigh) / 2)
						line.set_y2(_line, (high + _boxHigh) / 2)
						line.set_x2(_line, bar_index + 1)
					else if high >= _boxHigh and filterMitBOX
						_applyMitStyle(_box, _line, true)
			_boxLow := box.get_bottom(_box)
			_boxHigh := box.get_top(_box)
			_boxRight := box.get_right(_box)
			if bar_index == _boxRight and HighlightBox
				if gapmitigationtype == 'Engulf'
					if close <= _boxHigh and open <= _boxHigh and high > _boxLow
						_applyHighlight(_box, gapcolor)
						begaptouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("GAP- Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						begaptouch
				else if gapmitigationtype == 'Rebalance'
					if high < _boxHigh and high > _boxLow
						_applyHighlight(_box, gapcolor)
						begaptouch := true
						if wh_enable and wh_mitigations
							alert(_wh_json("GAP- Mitigated", _boxHigh, _boxLow), alert.freq_once_per_bar)
						begaptouch

alertcondition(ob_bullFormed, title = 'Bull OB Formed', message = 'Bull OB formed {{ticker}} {{interval}}')
alertcondition(ob_bearFormed, title = 'Bear OB Formed', message = 'Bear OB formed {{ticker}} {{interval}}')
alertcondition(ob_bullMit, title = 'Bull OB Mitigated', message = 'Bull OB mitigated {{ticker}} {{interval}}')
alertcondition(ob_bearMit, title = 'Bear OB Mitigated', message = 'Bear OB mitigated {{ticker}} {{interval}}')

alertcondition(barstate.isconfirmed and isFvgUp(0), title = 'FVG+', message = 'FVG+ {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and isFvgDown(0), title = 'FVG-', message = 'FVG- {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and isBuIFvg(0), title = 'Implied.FVG+', message = 'I.FVG+ {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and isBeIFvg(0), title = 'Implied.FVG-', message = 'I.FVG- {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and ((isBuVItype1(0) or isBuVItype2(0) or isBuVItype3(0)) and advancedvi or isBuVItype1(0) and classicvi), title = 'VI+', message = 'VI+ {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and ((isBeVItype1(0) or isBeVItype2(0) or isBeVItype3(0)) and advancedvi or isBeVItype1(0) and classicvi), title = 'VI-', message = 'VI- {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and high[1] < low, title = 'GAP+', message = 'GAP+ {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and low[1] > high, title = 'GAP-', message = 'GAP- {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and isbuinversefvg, title = 'Inverse.FVG+', message = 'Inverse.FVG+ {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and isbeinversefvg, title = 'Inverse.FVG-', message = 'Inverse.FVG- {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and bulv, title = 'LV+', message = 'LV+ {{ticker}} {{interval}}')
alertcondition(barstate.isconfirmed and belv, title = 'LV-', message = 'LV- {{ticker}} {{interval}}')
alertcondition(bugaptouch, title = 'GAP(+) Mitigation', message = 'GAP+ Mit {{ticker}} {{interval}}')
alertcondition(begaptouch, title = 'GAP(-) Mitigation', message = 'GAP- Mit {{ticker}} {{interval}}')
alertcondition(buimpfvgtouch, title = 'Implied.FVG(+) Mitigation', message = 'I.FVG+ Mit {{ticker}} {{interval}}')
alertcondition(beimpfvgtouch, title = 'Implied.FVG(-) Mitigation', message = 'I.FVG- Mit {{ticker}} {{interval}}')
alertcondition(bufvgtouch, title = 'FVG(+) Mitigation', message = 'FVG+ Mit {{ticker}} {{interval}}')
alertcondition(befvgtouch, title = 'FVG(-) Mitigation', message = 'FVG- Mit {{ticker}} {{interval}}')
alertcondition(buvitouch, title = 'VI(+) Mitigation', message = 'VI+ Mit {{ticker}} {{interval}}')
alertcondition(bevitouch, title = 'VI(-) Mitigation', message = 'VI- Mit {{ticker}} {{interval}}')
alertcondition(buinvfvgtouch, title = 'Inverse.FVG(+) Mitigation', message = 'Inv.FVG+ Mit {{ticker}} {{interval}}')
alertcondition(beinvfvgtouch, title = 'Inverse.FVG(-) Mitigation', message = 'Inv.FVG- Mit {{ticker}} {{interval}}')

type NWOGHelper
	string name

type NWOGSettings
	bool show
	color color
	color color_new
	int size
	string style
	color ce_color
	color ce_color_new
	int ce_size
	string ce_style
	string extend
	bool EH_show
	color EH_color
	string EH_style
	int EH_size
	int max_count
	bool use_background
	color background
	color background_new
	bool label_show
	string label_size
	color label_color
	color label_bgcolor

type GapBox
	line top
	label l_top
	line ce
	line bottom
	label l_bottom
	linefill fill

type Gap
	string name
	string date_name
	float open
	float middle
	float close
	int open_time
	int close_time
	GapBox gbox
	bool is_current = false
	bool is_sunday = false

type OpenGap
	Gap[] gaps
	NWOGSettings settings
	line EventHorizon = na

var nwog_gaps=array.new<Gap>()
var OpenGap NWOG=OpenGap.new()
NWOG.gaps := nwog_gaps
NWOG.settings := NWOGSettings.new()

var ndog_gaps=array.new<Gap>()
var OpenGap NDOG=OpenGap.new()
NDOG.gaps := ndog_gaps
NDOG.settings := NWOGSettings.new()

var ndogrth_gaps=array.new<Gap>()
var OpenGap NDOGrth=OpenGap.new()
NDOGrth.gaps := ndogrth_gaps
NDOGrth.settings := NWOGSettings.new()

var NWOGHelper nwogHelper=NWOGHelper.new()

NWOG_Group                  = "⑧ NWOG"
NDOG_Group                  = "⑨ NDOG ETH"
NDOGrth_Group               = "⑩ NDOG RTH"

NWOG.settings.show         := input.bool(true, "NWOG", group=NWOG_Group, inline="1")
NWOG.settings.color_new    := input.color(color.new(color.purple,0), '', group=NWOG_Group, inline='1')
NWOG.settings.color        := input.color(color.new(color.black,0), '', group=NWOG_Group, inline='1')
NWOG.settings.style        := input.string('⎯⎯⎯', '', options=['⎯⎯⎯', '----', '····'], group=NWOG_Group, inline='1')
NWOG.settings.size         := input.int(1, '', options=[1,2,3,4], group=NWOG_Group, inline='1')

NWOG.settings.ce_color_new := input.color(color.new(color.purple,0), 'C.E.              ', group=NWOG_Group, inline='3')
NWOG.settings.ce_color     := input.color(color.new(color.black,0), '', group=NWOG_Group, inline='3')
NWOG.settings.ce_style     := input.string('····', '', options=['⎯⎯⎯', '----', '····'], group=NWOG_Group, inline='3')
NWOG.settings.ce_size      := input.int(1, '', options=[1,2,3,4], group=NWOG_Group, inline='3')
NWOG.settings.EH_show      := input.bool(true, "Event Horizon", group=NWOG_Group, inline="4")
NWOG.settings.EH_color     := input.color(color.new(color.purple,20), "", group=NWOG_Group, inline='4')
NWOG.settings.EH_style     := input.string('----', '      ', options=['⎯⎯⎯', '----', '····'], group=NWOG_Group, inline='4')
NWOG.settings.EH_size      := input.int(1, '', options=[1,2,3,4], group=NWOG_Group, inline='4')

NWOG.settings.use_background    := input.bool(true, "Background", group=NWOG_Group, inline="5")
NWOG.settings.background_new    := input.color(color.new(color.purple,95), "", group=NWOG_Group, inline='5')
NWOG.settings.background        := input.color(color.new(color.black,95), "", group=NWOG_Group, inline='5')

NWOG.settings.label_show    := input.bool(true, "label", group=NWOG_Group, inline='2')
NWOG.settings.label_color   := input.color(color.black, "", group=NWOG_Group, inline='2')
NWOG.settings.label_bgcolor := input.color(color.new(color.orange, 100), "", group=NWOG_Group, inline='2')
NWOG.settings.label_size    := input.string(size.small, "", [size.auto, size.tiny, size.small, size.normal, size.large, size.huge], group=NWOG_Group, inline='2')
max_week=input.int(5, "Maximum number", 1, 50, group=NWOG_Group)
NWOG.settings.max_count := max_week
NWOG.settings.extend        := input.string("Always", "Extend Gaps", options=['Always', 'Above and below only', 'Any that is near current price'], group=NWOG_Group)

NDOG.settings.show         := input.bool(true, "NDOG ETH", group=NDOG_Group, inline='1')
NDOG.settings.color_new    := input.color(color.new(color.green,0), '', group=NDOG_Group, inline='1')
NDOG.settings.color        := input.color(color.new(color.blue,0), '', group=NDOG_Group, inline='1')
NDOG.settings.style        := input.string('⎯⎯⎯', '', options=['⎯⎯⎯', '----', '····'], group=NDOG_Group, inline='1')
NDOG.settings.size         := input.int(1, '', options=[1,2,3,4], group=NDOG_Group, inline='1')
NDOG.settings.ce_color_new := input.color(color.new(color.green,0), 'C.E.              ', group=NDOG_Group, inline='3')
NDOG.settings.ce_color     := input.color(color.new(color.blue,0), '', group=NDOG_Group, inline='3')
NDOG.settings.ce_style     := input.string('····', '', options=['⎯⎯⎯', '----', '····'], group=NDOG_Group, inline='3')
NDOG.settings.ce_size      := input.int(1, '', options=[1,2,3,4], group=NDOG_Group, inline='3')
NDOG.settings.use_background    := input.bool(true, "Background", group=NDOG_Group, inline="5")
NDOG.settings.background_new    := input.color(color.new(color.green,95), "", group=NDOG_Group, inline='5')
NDOG.settings.background        := input.color(color.new(color.blue,95), "", group=NDOG_Group, inline='5')

NDOG.settings.label_show    := input.bool(true, "label", group=NDOG_Group, inline='2')
NDOG.settings.label_color   := input.color(color.black, "", group=NDOG_Group, inline='2')
NDOG.settings.label_bgcolor := input.color(color.new(color.orange, 100), "", group=NDOG_Group, inline='2')
NDOG.settings.label_size    := input.string(size.small, "", [size.auto, size.tiny, size.small, size.normal, size.large, size.huge], group=NDOG_Group, inline='2')

NDOG.settings.max_count     := input.int(5, "Maximum number", 1, 50, group=NDOG_Group)
NDOG.settings.extend        := input.string("Always", "Extend Gaps", options=['Always', 'Above and below only', 'Any that is near current price'], group=NDOG_Group)

NDOGrth.settings.show         := input.bool(true, "NDOG RTH", group=NDOGrth_Group, inline='1')
NDOGrth.settings.color_new    := input.color(color.new(color.orange,0), '', group=NDOGrth_Group, inline='1')
NDOGrth.settings.color        := input.color(color.new(color.red,0), '', group=NDOGrth_Group, inline='1')
NDOGrth.settings.style        := input.string('⎯⎯⎯', '', options=['⎯⎯⎯', '----', '····'], group=NDOGrth_Group, inline='1')
NDOGrth.settings.size         := input.int(1, '', options=[1,2,3,4], group=NDOGrth_Group, inline='1')
NDOGrth.settings.ce_color_new := input.color(color.new(color.orange,0), 'C.E.              ', group=NDOGrth_Group, inline='3')
NDOGrth.settings.ce_color     := input.color(color.new(color.red,0), '', group=NDOGrth_Group, inline='3')
NDOGrth.settings.ce_style     := input.string('····', '', options=['⎯⎯⎯', '----', '····'], group=NDOGrth_Group, inline='3')
NDOGrth.settings.ce_size      := input.int(1, '', options=[1,2,3,4], group=NDOGrth_Group, inline='3')
NDOGrth.settings.use_background    := input.bool(true, "Background", group=NDOGrth_Group, inline="5")
NDOGrth.settings.background_new    := input.color(color.new(color.orange,95), "", group=NDOGrth_Group, inline='5')
NDOGrth.settings.background        := input.color(color.new(color.red,95), "", group=NDOGrth_Group, inline='5')

NDOGrth.settings.label_show    := input.bool(true, "label", group=NDOGrth_Group, inline='2')
NDOGrth.settings.label_color   := input.color(color.black, "", group=NDOGrth_Group, inline='2')
NDOGrth.settings.label_bgcolor := input.color(color.new(color.orange, 100), "", group=NDOGrth_Group, inline='2')
NDOGrth.settings.label_size    := input.string(size.small, "", [size.auto, size.tiny, size.small, size.normal, size.large, size.huge], group=NDOGrth_Group, inline='2')

NDOGrth.settings.max_count    := input.int(5, "Maximum number", 1, 50, group=NDOGrth_Group)
NDOGrth.settings.extend       := input.string("Always", "Extend Gaps", options=['Always', 'Above and below only', 'Any that is near current price'], group=NDOGrth_Group)

distance=input.int(200, "Number of candles to use in calculation", group="⑪ Advanced (NWOG/NDOG)")
factor=input.float(20, "Factor multiplier for distance test", group="⑪ Advanced (NWOG/NDOG)")
buffer=input.int(10, "Buffer - Number of candles to extend by", minval=0, group="⑪ Advanced (NWOG/NDOG)")+1

atrf = ta.atr(distance) + (ta.stdev(high - low, distance)*factor)
dt = time - time[1]

var float[] median=array.new_float()
length = 500
median.unshift(high-low)
if median.size() > length
	median.pop()
float spacing = ta.sma(ta.sma(median.median(), length), length) *.5

method AbovePrice(Gap[] gaps, price) =>
	float delta = -1
	sz = gaps.size()
	Gap _return = na
	if sz > 0
		for i= sz-1 to 0
			Gap ng = gaps.get(i)
			float mark = math.max(ng.open, ng.close)
			if price < mark
				ndelta = math.abs(mark - price)
				delta := delta == -1 ? ndelta : delta
				if ndelta <= delta
					delta := ndelta
					_return := ng
	_return

method BelowPrice(Gap[] gaps, price) =>
	float delta = -1
	sz = gaps.size()
	Gap _return = na
	if sz > 0
		for i=0 to sz-1
			Gap ng = gaps.get(i)
			float mark = math.min(ng.open, ng.close)
			if price > mark
				ndelta = math.abs(price - mark)
				delta := delta == -1 ? ndelta : delta
				if ndelta <= delta
					delta := ndelta
					_return := ng
	_return

method render(Gap gap, NWOGSettings settings) =>
	int e = time + (dt*buffer)
	float middle = (gap.open+gap.close)/2
	if not (str.contains(gap.name, "NDOG") and gap.is_sunday and NWOG.settings.show)
		if na(gap.gbox)
			gap.gbox := GapBox.new()
			gap.gbox.top := line.new(gap.open_time, math.max(gap.open, gap.close), e, math.max(gap.open, gap.close), xloc=xloc.bar_time, color=gap.is_current ? settings.color_new : settings.color, width = settings.size, style=f_get_line_style(settings.style))
			gap.gbox.bottom := line.new(gap.open_time, math.min(gap.open, gap.close), e, math.min(gap.open, gap.close), xloc=xloc.bar_time, color=gap.is_current ? settings.color_new : settings.color, width = settings.size, style=f_get_line_style(settings.style))
			gap.gbox.ce := line.new(gap.open_time, middle, e, middle, xloc=xloc.bar_time, color=gap.is_current ? settings.ce_color_new : settings.ce_color, width = settings.ce_size, style=f_get_line_style(settings.ce_style))
			if settings.use_background
				gap.gbox.fill := linefill.new(gap.gbox.top, gap.gbox.bottom, gap.is_current ? settings.background_new : settings.background)
		else
			line.set_x2(gap.gbox.top, e)
			line.set_x2(gap.gbox.bottom, e)
			line.set_x2(gap.gbox.ce, e)
			line.set_color(gap.gbox.top, gap.is_current ? settings.color_new : settings.color)
			line.set_color(gap.gbox.bottom, gap.is_current ? settings.color_new : settings.color)
			line.set_color(gap.gbox.ce, gap.is_current ? settings.ce_color_new : settings.ce_color)
			linefill.set_color(gap.gbox.fill, gap.is_current ? settings.background_new : settings.background)

		if settings.label_show
			if na(gap.gbox.l_top)
				if math.abs(gap.open - gap.close) >= spacing
					gap.gbox.l_top       := label.new(e, math.max(gap.close, gap.open), str.format("{1} high -{0}", gap.date_name, gap.name), style=label.style_label_left, xloc=xloc.bar_time, size=settings.label_size, color=settings.label_bgcolor, textcolor=settings.label_color)
					gap.gbox.l_bottom    := label.new(e, math.min(gap.close, gap.open), str.format("{1} low -{0}", gap.date_name, gap.name), style=label.style_label_left, xloc=xloc.bar_time, size=settings.label_size, color=settings.label_bgcolor, textcolor=settings.label_color)
				else
					gap.gbox.l_top       := label.new(e, gap.middle, str.format("{1} -{0}", gap.date_name, gap.name), style=label.style_label_left, xloc=xloc.bar_time, size=settings.label_size, color=settings.label_bgcolor, textcolor=settings.label_color)
					label.delete(gap.gbox.l_bottom)
			else
				if math.abs(gap.open - gap.close) >= spacing
					label.set_x(gap.gbox.l_top, e)
					label.set_x(gap.gbox.l_bottom, e)
				else
					label.set_x(gap.gbox.l_top, e)
	gap

method reset(Gap gap) =>
	if not na(gap.gbox)
		line.delete(gap.gbox.top)
		line.delete(gap.gbox.bottom)
		line.delete(gap.gbox.ce)
		linefill.delete(gap.gbox.fill)
		label.delete(gap.gbox.l_top)
		label.delete(gap.gbox.l_bottom)
		gap.gbox := na

method Add(OpenGap GAP, string name, float o, float c, int t, int t1, int tt) =>
	gap = Gap.new()
	gap.name := name
	gap.date_name   := str.format("{0, date, MMM, d yyyy}", tt)
	gap.open := c
	gap.close := o
	gap.middle := (o+c)/2
	gap.open_time := t1
	gap.close_time := t
	gap.is_sunday := dayofweek == dayofweek.sunday
	GAP.gaps.unshift(gap)

	if GAP.gaps.size() > GAP.settings.max_count
		g = GAP.gaps.pop()
		g.reset()

	GAP

method Redraw(OpenGap GAP) =>
	if GAP.gaps.size() > 0
		for i = 0 to GAP.gaps.size()-1
			g = GAP.gaps.get(i)
			g.is_current := i == 0
			switch GAP.settings.extend
				"Always" =>
					g.render(GAP.settings)
				"Above and below only" =>
					g.reset()
				"Any that is near current price" =>
					t = (math.min(g.open, g.close) - high)
					l = (low - math.max(g.open, g.close))
					if (t > 0 and t < atrf) or (l > 0 and l < atrf)
						g.render(GAP.settings)
					else
						g.reset()
		if GAP.settings.extend == 'Above and below only' or GAP.settings.EH_show
			prev = GAP.gaps.AbovePrice(close)
			next = GAP.gaps.BelowPrice(close)
			if GAP.settings.extend == "Above and below only"
				if not na(prev)
					prev.render(GAP.settings)
				if not na(next)
					next.render(GAP.settings)

			if GAP.settings.EH_show
				if not na(prev) and not na(next)
					if math.min(prev.open, prev.close) > math.max(next.open, next.close)
						middle = (math.min(prev.open, prev.close) + math.max(next.open, next.close))/2
						if na(GAP.EventHorizon)
							GAP.EventHorizon := line.new(math.max(prev.open_time, next.open_time), middle, time+(time-time[1])*buffer, middle, xloc=xloc.bar_time, color=GAP.settings.EH_color, width = GAP.settings.EH_size, style=f_get_line_style(GAP.settings.EH_style))
						else
							line.set_xy1(GAP.EventHorizon, math.max(prev.open_time, next.open_time), middle)
							line.set_xy2(GAP.EventHorizon, time+(time-time[1])*buffer, middle)
					else
						line.delete(GAP.EventHorizon)
				else
					line.delete(GAP.EventHorizon)
					1
			else
				line.delete(GAP.EventHorizon)
				1
	GAP

getCloseAtTime() =>
	float closed = na
	int closedtime = 0
	if timeframe.isseconds
		[isclosed, closeAt, closedAtTime] = request.security(syminfo.tickerid, "1", [(hour(time[1], "America/New_York") == 16 and minute(time[1], "America/New_York") == 14), close[1], time[1]], lookahead=barmerge.lookahead_on)
		if isclosed
			closed := closeAt
			closedtime := closedAtTime
	else
		[isclosed, closeAt, closedAtTime] = request.security_lower_tf(syminfo.tickerid, "1", [(hour(time[1], "America/New_York") == 16 and minute(time[1], "America/New_York") == 14), close[1], time[1]])
		int index = na
		if isclosed.size() > 0
			for i = 0 to isclosed.size() - 1
				if isclosed.get(i)
					index := i
					break
			if not na(index)
				if closeAt.size() >= index
					closed := closeAt.get(index)
				if closedAtTime.size() >= index
					closedtime := closedAtTime.get(index)
	[closed, closedtime]

getOpenAtTime() =>
	float opened = na
	int openedtime = 0
	if timeframe.isseconds
		if ta.change(time("1")) != 0
			[isopened, openAt, openedAtTime] = request.security(syminfo.tickerid, "1", [(hour(time[1], "America/New_York") == 18 and minute(time[1], "America/New_York") == 0), open[1], time[1]], lookahead=barmerge.lookahead_on)
			if isopened
				opened := openAt
				openedtime := openedAtTime
	else
		[isopened, openAt, openedAtTime] = request.security_lower_tf(syminfo.tickerid, "1", [(hour(time[1], "America/New_York") == 18 and minute(time[1], "America/New_York") == 0), open[1], time[1]])
		int index = na
		if isopened.size() > 0
			for i = 0 to isopened.size() - 1
				if isopened.get(i)
					index := i
					break
			if not na(index)
				if openAt.size() >= index
					opened := openAt.get(index)
				if openedAtTime.size() >=index
					openedtime := openedAtTime.get(index)
	[opened, openedtime]

if barstate.isconfirmed and ENABLE_NWOG_NDOG
	is_sunday = dayofweek == dayofweek.sunday
	if NWOG.settings.show and timeframe.isintraday
		if not is_sunday[1] and is_sunday
			NWOG.Add("NWOG", open, close[1], time, time[1], time)
		NWOG.Redraw()

	if NDOG.settings.show and timeframe.isintraday
		dailyBarTime = time('1D')
		isNewDay = ta.change(dailyBarTime) != 0
		if isNewDay and open != close[1]
			NDOG.Add("NDOG ETH", open, close[1], time, time[1], time)
		NDOG.Redraw()

	if NDOGrth.settings.show and timeframe.isintraday
		var float nwog_closed=na
		var int nwog_closedtime=0
		var float nwog_opened=na
		var int nwog_openedtime=0

		if na(nwog_closed)
			[closedAt, closedAttime] = getCloseAtTime()
			if not na(closedAt)
				nwog_closed := closedAt
				nwog_closedtime := closedAttime

		[openedAt, openedAttime] = getOpenAtTime()
		nwog_opened := openedAt
		nwog_openedtime := openedAttime

		if not na(nwog_opened)
			NDOGrth.Add("NDOG RTH", nwog_closed, nwog_opened, nwog_closedtime, nwog_openedtime, nwog_closedtime)
			nwog_closed := na
			nwog_opened := na
		NDOGrth.Redraw()

type Candle
	float o
	float c
	float h
	float l
	int o_time
	int o_idx
	int c_idx
	int h_idx
	int l_idx
	string dow
	box body
	line wick_up
	line wick_down
	label dow_label

type Trace
	line o
	line c
	line h
	line l
	label o_l
	label c_l
	label h_l
	label l_l

type Imbalance
	box b
	int idx

type CandleSettings
	bool show
	string htf
	int max_display

type HTFSettings
	int max_sets
	color bull_body
	color bull_border
	color bull_wick
	color bear_body
	color bear_border
	color bear_wick
	int offset
	int buffer
	int htf_buffer
	int width
	bool use_custom_daily
	string custom_daily
	bool daily_name
	bool trace_show
	color trace_o_color
	string trace_o_style
	int trace_o_size
	color trace_c_color
	string trace_c_style
	int trace_c_size
	color trace_h_color
	string trace_h_style
	int trace_h_size
	color trace_l_color
	string trace_l_style
	int trace_l_size
	string trace_anchor
	bool label_show
	color label_color
	string label_size
	string label_position
	string label_alignment
	bool fvg_show
	color fvg_color
	bool vi_show
	color vi_color
	bool htf_label_show
	color htf_label_color
	string htf_label_size
	bool htf_timer_show
	color htf_timer_color
	string htf_timer_size
	color dow_color
	string dow_size

type CandleSet
	array<Candle> candles
	array<Imbalance> imbalances
	CandleSettings csettings
	label tfNameTop
	label tfNameBottom
	label tfTimerTop
	label tfTimerBottom
	int prevBarTime = na

HTFSettings htfSettings = HTFSettings.new()

var CandleSettings SettingsHTF1=CandleSettings.new()
var CandleSettings SettingsHTF2=CandleSettings.new()
var CandleSettings SettingsHTF3=CandleSettings.new()
var CandleSettings SettingsHTF4=CandleSettings.new()
var CandleSettings SettingsHTF5=CandleSettings.new()
var CandleSettings SettingsHTF6=CandleSettings.new()

var array<Candle> candles_1=array.new<Candle>(0)
var array<Candle> candles_2=array.new<Candle>(0)
var array<Candle> candles_3=array.new<Candle>(0)
var array<Candle> candles_4=array.new<Candle>(0)
var array<Candle> candles_5=array.new<Candle>(0)
var array<Candle> candles_6=array.new<Candle>(0)

var array<Imbalance> imbalances_1=array.new<Imbalance>()
var array<Imbalance> imbalances_2=array.new<Imbalance>()
var array<Imbalance> imbalances_3=array.new<Imbalance>()
var array<Imbalance> imbalances_4=array.new<Imbalance>()
var array<Imbalance> imbalances_5=array.new<Imbalance>()
var array<Imbalance> imbalances_6=array.new<Imbalance>()

var CandleSet htf1=CandleSet.new()
htf1.csettings := SettingsHTF1
htf1.candles := candles_1
htf1.imbalances := imbalances_1

var CandleSet htf2=CandleSet.new()
htf2.csettings := SettingsHTF2
htf2.candles := candles_2
htf2.imbalances := imbalances_2

var CandleSet htf3=CandleSet.new()
htf3.csettings := SettingsHTF3
htf3.candles := candles_3
htf3.imbalances := imbalances_3

var CandleSet htf4=CandleSet.new()
htf4.csettings := SettingsHTF4
htf4.candles := candles_4
htf4.imbalances := imbalances_4

var CandleSet htf5=CandleSet.new()
htf5.csettings := SettingsHTF5
htf5.candles := candles_5
htf5.imbalances := imbalances_5

var CandleSet htf6=CandleSet.new()
htf6.csettings := SettingsHTF6
htf6.candles := candles_6
htf6.imbalances := imbalances_6

var array<CandleSet> htfSets = array.from(htf1, htf2, htf3, htf4, htf5, htf6)

string group_htfc_style              = "⑬ HTF Candle Styling"
string group_htfc_label              = "⑭ HTF Candle Labels"
string group_htfc_imbalance          = "⑮ HTF Candle Imbalance"
string group_htfc_trace              = "⑯ HTF Candle Trace"

htf1.csettings.show              := input.bool(true, 'HTF 1      ', inline='htf1', group='⑫ HTF Candles')
htf_1=input.timeframe('5', '', inline='htf1', group='⑫ HTF Candles')
htf1.csettings.htf := htf_1
htf1.csettings.max_display       := input.int(10, '', inline='htf1', group='⑫ HTF Candles')

htf2.csettings.show              := input.bool(true, 'HTF 2      ', inline='htf2', group='⑫ HTF Candles')
htf_2=input.timeframe('15', '', inline='htf2', group='⑫ HTF Candles')
htf2.csettings.htf := htf_2
htf2.csettings.max_display       := input.int(10, '', inline='htf2', group='⑫ HTF Candles')

htf3.csettings.show              := input.bool(true, 'HTF 3      ', inline='htf3', group='⑫ HTF Candles')
htf_3=input.timeframe('60', '', inline='htf3', group='⑫ HTF Candles')
htf3.csettings.htf := htf_3
htf3.csettings.max_display       := input.int(10, '', inline='htf3', group='⑫ HTF Candles')

htf4.csettings.show              := input.bool(true, 'HTF 4      ', inline='htf4', group='⑫ HTF Candles')
htf_4=input.timeframe('240', '', inline='htf4', group='⑫ HTF Candles')
htf4.csettings.htf := htf_4
htf4.csettings.max_display       := input.int(10, '', inline='htf4', group='⑫ HTF Candles')

htf5.csettings.show              := input.bool(true, 'HTF 5      ', inline='htf5', group='⑫ HTF Candles')
htf_5=input.timeframe('1D', '', inline='htf5', group='⑫ HTF Candles')
htf5.csettings.htf := htf_5
htf5.csettings.max_display       := input.int(10, '', inline='htf5', group='⑫ HTF Candles')

htf6.csettings.show              := input.bool(true, 'HTF 6      ', inline='htf6', group='⑫ HTF Candles')
htf_6=input.timeframe('1W', '', inline='htf6', group='⑫ HTF Candles')
htf6.csettings.htf := htf_6
htf6.csettings.max_display       := input.int(10, '', inline='htf6', group='⑫ HTF Candles')

htfSettings.max_sets               := input.int(6, 'Limit to next HTFs only', minval=1, maxval=6, group='⑫ HTF Candles')
htfSettings.use_custom_daily       := input.bool(false, 'Custom daily candle open     ', inline='customdaily', group='⑫ HTF Candles')
htfSettings.custom_daily           := input.string('Midnight', '', options=['Midnight', '8:30', '9:30'], inline='customdaily', group='⑫ HTF Candles')
htfSettings.bull_body              := input.color(color.new(color.green, 10), 'Body  ', inline='body', group=group_htfc_style)
htfSettings.bear_body              := input.color(color.new(color.red, 10), '', inline='body', group=group_htfc_style)
htfSettings.bull_border            := input.color(color.new(color.black, 10), 'Borders', inline='borders', group=group_htfc_style)
htfSettings.bear_border            := input.color(color.new(color.black, 10), '', inline='borders', group=group_htfc_style)
htfSettings.bull_wick              := input.color(color.new(color.black, 10), 'Wick  ', inline='wick', group=group_htfc_style)
htfSettings.bear_wick              := input.color(color.new(color.black, 10), '', inline='wick', group=group_htfc_style)

htfSettings.offset                 := input.int(10, 'padding from current candles', minval=1, group=group_htfc_style)
htfSettings.buffer                 := input.int(1, 'space between candles', minval=1, maxval=4, group=group_htfc_style)
htfSettings.htf_buffer             := input.int(10, 'space between Higher Timeframes', minval=1, maxval=10, group=group_htfc_style)
htfSettings.width                  := input.int(1, 'Candle Width', minval=1, maxval=4, group=group_htfc_style) * 2

htfSettings.htf_label_show         := input.bool(true, 'HTF Label           ', group=group_htfc_label, inline='HTFlabel')
htfSettings.htf_label_color        := input.color(color.new(color.black, 10), '', group=group_htfc_label, inline='HTFlabel')
htfSettings.htf_label_size         := input.string(size.large, '', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_htfc_label, inline='HTFlabel')

htfSettings.label_position         := input.string("Both", 'Label Positions', options=['Both', 'Top', 'Bottom'], group=group_htfc_label)
htfSettings.label_alignment        := input.string("Align", "Label Alignment", options=['Align', 'Follow Candles'], group=group_htfc_label)

htfSettings.htf_timer_show         := input.bool(true, 'Remaining time      ', inline='timer', group=group_htfc_label)
htfSettings.htf_timer_color        := input.color(color.new(color.black, 10), '', inline='timer', group=group_htfc_label)
htfSettings.htf_timer_size         := input.string(size.normal, '', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_htfc_label, inline='timer')

htfSettings.daily_name             := input.bool(false, 'Interval Value        ', group=group_htfc_label, inline='dow')
htfSettings.dow_color              := input.color(color.black , '', group=group_htfc_label, inline='dow')
htfSettings.dow_size               := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], group=group_htfc_label, inline='dow')

htfSettings.fvg_show               := input.bool(true, 'Fair Value Gap   ', group=group_htfc_imbalance, inline='fvg')
htfSettings.fvg_color              := input.color(color.new(color.gray, 80), '', inline='fvg', group=group_htfc_imbalance)

htfSettings.vi_show                := input.bool(true, 'Volume Imbalance', group=group_htfc_imbalance, inline='vi')
htfSettings.vi_color               := input.color(color.new(color.red, 50), '', inline='vi', group=group_htfc_imbalance)

htfSettings.trace_show             := input.bool(false, 'Trace lines', group=group_htfc_trace)
htfSettings.trace_o_color          := input.color(color.new(color.gray, 50), 'Open    ', inline='1', group=group_htfc_trace)
htfSettings.trace_o_style          := input.string('····', '', options=['⎯⎯⎯', '----', '····'], inline='1', group=group_htfc_trace)
htfSettings.trace_o_size           := input.int(1, '', options=[1, 2, 3, 4], inline='1', group=group_htfc_trace)
htfSettings.trace_c_color          := input.color(color.new(color.gray, 50), 'Close    ', inline='2', group=group_htfc_trace)
htfSettings.trace_c_style          := input.string('····', '', options=['⎯⎯⎯', '----', '····'], inline='2', group=group_htfc_trace)
htfSettings.trace_c_size           := input.int(1, '', options=[1, 2, 3, 4], inline='2', group=group_htfc_trace)
htfSettings.trace_h_color          := input.color(color.new(color.gray, 50), 'High     ', inline='3', group=group_htfc_trace)
htfSettings.trace_h_style          := input.string('····', '', options=['⎯⎯⎯', '----', '····'], inline='3', group=group_htfc_trace)
htfSettings.trace_h_size           := input.int(1, '', options=[1, 2, 3, 4], inline='3', group=group_htfc_trace)
htfSettings.trace_l_color          := input.color(color.new(color.gray, 50), 'Low     ', inline='4', group=group_htfc_trace)
htfSettings.trace_l_style          := input.string('····', '', options=['⎯⎯⎯', '----', '····'], inline='4', group=group_htfc_trace)
htfSettings.trace_l_size           := input.int(1, '', options=[1, 2, 3, 4], inline='4', group=group_htfc_trace)
htfSettings.trace_anchor           := input.string('First Timeframe', 'Anchor to', options=['First Timeframe', 'Last Timeframe'], group=group_htfc_trace)

htfSettings.label_show             := input.bool(false, 'Price Label           ', inline='label', group=group_htfc_trace)
htfSettings.label_color            := input.color(color.new(color.black, 10), '', inline='label', group=group_htfc_trace)
htfSettings.label_size             := input.string(size.small, '', [size.tiny, size.small, size.normal, size.large, size.huge], inline='label', group=group_htfc_trace)

var Trace htfTrace=Trace.new()
color htfc_color_transparent = #ffffff00

_htf_LineStyle(string style) =>
	out = switch style
		'----' => line.style_dashed
		'····' => line.style_dotted
		=> line.style_solid
	out

_htf_DayofWeek(int index) =>
	switch
		index == 1 => 'M'
		index == 2 => 'T'
		index == 3 => 'W'
		index == 4 => 'T'
		index == 5 => 'F'
		index == 6 => 'S'
		index == 7 => 'S'
		na(index) => ''

_htf_ValidTimeframe(string HTF) =>
	if timeframe.in_seconds(HTF) >= timeframe.in_seconds('D') and timeframe.in_seconds(HTF) > timeframe.in_seconds()
		true
	else
		n1 = timeframe.in_seconds()
		n2 = timeframe.in_seconds(HTF)
		n3 = n1 % n2
		n1 < n2 and math.round(n2 / n1) == n2 / n1

_htf_RemainingTime(string HTF) =>
	if barstate.isrealtime
		timeRemaining = (time_close(HTF) - timenow) / 1000
		days = math.floor(timeRemaining / 86400)
		hours = math.floor((timeRemaining - days * 86400) / 3600)
		minutes = math.floor((timeRemaining - days * 86400 - hours * 3600) / 60)
		seconds = math.floor(timeRemaining - days * 86400 - hours * 3600 - minutes * 60)

		r = str.tostring(seconds, '00')
		if minutes > 0 or hours > 0 or days > 0
			r := str.tostring(minutes, '00') + ':' + r
			r
		if hours > 0 or days > 0
			r := str.tostring(hours, '00') + ':' + r
			r
		if days > 0
			r := str.tostring(days) + 'D ' + r
			r
		r
	else
		'n/a'

_htf_HTFName(string HTF) =>
	formatted = HTF

	seconds = timeframe.in_seconds(HTF)
	if seconds < 60
		formatted := str.tostring(seconds) + 's'
		formatted
	else if seconds / 60 < 60
		formatted := str.tostring(seconds / 60) + 'm'
		formatted
	else if seconds / 60 / 60 < 24
		formatted := str.tostring(seconds / 60 / 60) + 'H'
		formatted
	formatted

_htf_Enabled() =>
	int enabled = 0
	for i = 0 to htfSets.size() - 1
		if htfSets.get(i).csettings.show
			enabled += 1
	math.min(enabled, htfSettings.max_sets)

_htf_CandleSetHigh(array<Candle> candles, float h) =>
	float _h = h
	if array.size(candles) > 0
		for i = 0 to array.size(candles) - 1 by 1
			Candle c = array.get(candles, i)
			if c.h > _h
				_h := c.h
				_h
	_h

_htf_CandleSetLow(array<Candle> candles, float l) =>
	float _l = l
	if array.size(candles) > 0
		for i = 0 to array.size(candles) - 1 by 1
			Candle c = array.get(candles, i)
			if c.l < _l
				_l := c.l
				_l
	_l

_htf_CandlesHigh(array<Candle> candles) =>
	h = 0.0
	int cnt = 0
	int last = _htf_Enabled()
	for i = 0 to htfSets.size() - 1
		CandleSet _cs = htfSets.get(i)
		if _cs.csettings.show and _htf_ValidTimeframe(_cs.csettings.htf) and cnt < last
			h := _htf_CandleSetHigh(_cs.candles, h)
			cnt += 1
	if array.size(candles) > 0
		for i = 0 to array.size(candles) - 1
			Candle c = array.get(candles, i)
			if c.h > h
				h := c.h
	h

_htf_CandlesLow(array<Candle> candles, float h) =>
	l = h
	int cnt = 0
	int last = _htf_Enabled()
	for i = 0 to htfSets.size() - 1
		CandleSet _cs = htfSets.get(i)
		if _cs.csettings.show and _htf_ValidTimeframe(_cs.csettings.htf) and cnt < last
			l := _htf_CandleSetLow(_cs.candles, l)
			cnt += 1
	if array.size(candles) > 0
		for i = 0 to array.size(candles) - 1
			Candle c = array.get(candles, i)
			if c.l < l
				l := c.l
	l

method UpdateTime(CandleSet candleSet, int offset) =>
	if htfSettings.htf_timer_show and (barstate.isrealtime or barstate.islast)
		string tmr = '(' + _htf_RemainingTime(candleSet.csettings.htf) + ')'

		if not na(candleSet.tfTimerTop)
			candleSet.tfTimerTop.set_text(tmr)

		if not na(candleSet.tfTimerBottom)
			candleSet.tfTimerBottom.set_text(tmr)
	candleSet

method Reorder(CandleSet candleSet, int offset) =>
	size = candleSet.candles.size()

	if size > 0
		for i = size - 1 to 0 by 1
			Candle candle = candleSet.candles.get(i)
			t_buffer = offset + (htfSettings.width + htfSettings.buffer) * (size - i - 1)
			box.set_left(candle.body, bar_index + t_buffer)
			box.set_right(candle.body, bar_index + htfSettings.width + t_buffer)
			line.set_x1(candle.wick_up, bar_index + htfSettings.width / 2 + t_buffer)
			line.set_x2(candle.wick_up, bar_index + htfSettings.width / 2 + t_buffer)
			line.set_x1(candle.wick_down, bar_index + htfSettings.width / 2 + t_buffer)
			line.set_x2(candle.wick_down, bar_index + htfSettings.width / 2 + t_buffer)

			if htfSettings.daily_name
				if not na(candle.dow_label)
					candle.dow_label.set_y(candle.h)
					candle.dow_label.set_x(bar_index + htfSettings.width / 2 + t_buffer)
					candle.dow_label.set_text(candle.dow)
				else
					candle.dow_label := label.new(bar_index + htfSettings.width / 2 + t_buffer, candle.h, candle.dow, color = htfc_color_transparent, textcolor = htfSettings.dow_color, style = label.style_label_down, size = htfSettings.dow_size)

	top = 0.0
	bottom = 0.0

	if htfSettings.label_alignment == 'Align'
		top := _htf_CandlesHigh(candleSet.candles)
		bottom := _htf_CandlesLow(candleSet.candles, top)
	if htfSettings.label_alignment == 'Follow Candles'
		top := _htf_CandleSetHigh(candleSet.candles, 0)
		bottom := _htf_CandleSetLow(candleSet.candles, top)

	left = bar_index + offset + (htfSettings.width + htfSettings.buffer) * (size - 1) / 2

	if htfSettings.htf_label_show
		string lblt = _htf_HTFName(candleSet.csettings.htf)
		string lbll = lblt
		if htfSettings.htf_timer_show
			lblt := lblt + '\n'
			lbll := '\n' + lbll
		if htfSettings.daily_name
			lblt := lblt + '\n'

		string tmr = '(' + _htf_RemainingTime(candleSet.csettings.htf) + ')' + (htfSettings.daily_name ? '\n' : '')
		if htfSettings.label_position == 'Both' or htfSettings.label_position == 'Top'

			if not na(candleSet.tfNameTop)
				candleSet.tfNameTop.set_xy(left, top)
			else
				candleSet.tfNameTop := label.new(left, top, lblt, color = htfc_color_transparent, textcolor = htfSettings.htf_label_color, style = label.style_label_down, size = htfSettings.htf_label_size)
			if htfSettings.htf_timer_show
				if not na(candleSet.tfTimerTop)
					candleSet.tfTimerTop.set_xy(left, top)
				else
					candleSet.tfTimerTop := label.new(left, top, tmr, color = htfc_color_transparent, textcolor = htfSettings.htf_timer_color, style = label.style_label_down, size = htfSettings.htf_timer_size)

		if htfSettings.label_position == 'Both' or htfSettings.label_position == 'Bottom'
			if not na(candleSet.tfNameBottom)
				candleSet.tfNameBottom.set_xy(left, bottom)
			else
				candleSet.tfNameBottom := label.new(left, bottom, lbll, color = htfc_color_transparent, textcolor = htfSettings.htf_label_color, style = label.style_label_up, size = htfSettings.htf_label_size)
			if htfSettings.htf_timer_show
				if htfSettings.htf_timer_show
					if not na(candleSet.tfTimerBottom)
						candleSet.tfTimerBottom.set_xy(left, bottom)
					else
						candleSet.tfTimerBottom := label.new(left, bottom, tmr, color = htfc_color_transparent, textcolor = htfSettings.htf_timer_color, style = label.style_label_up, size = htfSettings.htf_timer_size)

	candleSet

method FindImbalance(CandleSet candleSet) =>
	if barstate.isrealtime or barstate.islast
		if candleSet.imbalances.size() > 0
			for i = candleSet.imbalances.size() - 1 to 0 by 1
				Imbalance del = candleSet.imbalances.get(i)
				box.delete(del.b)
				candleSet.imbalances.pop()

		if candleSet.candles.size() > 3 and htfSettings.fvg_show
			for i = 0 to candleSet.candles.size() - 3 by 1
				candle1 = candleSet.candles.get(i)
				candle2 = candleSet.candles.get(i + 2)
				candle3 = candleSet.candles.get(i + 1)

				if candle1.l > candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
					Imbalance imb = Imbalance.new()
					imb.b := box.new(box.get_left(candle2.body), candle2.h, box.get_right(candle1.body), candle1.l, bgcolor = htfSettings.fvg_color, border_color = htfc_color_transparent, xloc = xloc.bar_index)
					candleSet.imbalances.push(imb)
				if candle1.h < candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
					Imbalance imb = Imbalance.new()
					imb.b := box.new(box.get_right(candle1.body), candle1.h, box.get_left(candle2.body), candle2.l, bgcolor = htfSettings.fvg_color, border_color = htfc_color_transparent)
					candleSet.imbalances.push(imb)
				box temp = box.copy(candle3.body)
				box.delete(candle3.body)
				candle3.body := temp
				candle3.body

		if candleSet.candles.size() > 2 and htfSettings.vi_show
			for i = 0 to candleSet.candles.size() - 2 by 1
				candle1 = candleSet.candles.get(i)
				candle2 = candleSet.candles.get(i + 1)
				if candle1.l < candle2.h and math.min(candle1.o, candle1.c) > math.max(candle2.o, candle2.c)
					Imbalance imb = Imbalance.new()
					imb.b := box.new(box.get_left(candle2.body), math.min(candle1.o, candle1.c), box.get_right(candle1.body), math.max(candle2.o, candle2.c), bgcolor = htfSettings.vi_color, border_color = htfc_color_transparent)
					candleSet.imbalances.push(imb)
				if candle1.h > candle2.l and math.max(candle1.o, candle1.c) < math.min(candle2.o, candle2.c)
					Imbalance imb = Imbalance.new()
					imb.b := box.new(box.get_right(candle1.body), math.min(candle2.o, candle2.c), box.get_left(candle2.body), math.max(candle1.o, candle1.c), bgcolor = htfSettings.vi_color, border_color = htfc_color_transparent)
					candleSet.imbalances.push(imb)
	candleSet

method Monitor(CandleSet candleSet) =>
	int HTFBarTime = time(candleSet.csettings.htf, 'america/New_York')
	bool isNewHTFCandle = not na(HTFBarTime) and (na(candleSet.prevBarTime) or HTFBarTime != candleSet.prevBarTime)
	candleSet.prevBarTime := HTFBarTime

	if htfSettings.use_custom_daily
		int _830 = 0
		if isNewHTFCandle
			_830 := timestamp("America/New_York", year(time), month(time), dayofmonth(time), 0, 0) + 30600000
		if candleSet.csettings.htf == '1D'
			if htfSettings.custom_daily == 'Midnight'
				isNewHTFCandle := dayofweek(time, 'America/New_York') != dayofweek(time - (time - time[1]), 'America/New_York')
			if htfSettings.custom_daily == '8:30'
				isNewHTFCandle := not na(time(timeframe.period, "0830-0831:123456", 'America/New_York')) and na(time(timeframe.period, "0830-0831:123456", 'America/New_York')[1])
			if htfSettings.custom_daily == '9:30'
				isNewHTFCandle := not na(time(timeframe.period, "0930-0931:123456", 'America/New_York')) and na(time(timeframe.period, "0930-0931:123456", 'America/New_York')[1])
	if isNewHTFCandle
		Candle candle = Candle.new()
		candle.o := open
		candle.c := close
		candle.h := high
		candle.l := low
		candle.o_time := time
		candle.o_idx := bar_index
		candle.c_idx := bar_index
		candle.h_idx := bar_index
		candle.l_idx := bar_index
		candle.dow := switch
			candleSet.csettings.htf == '1D' =>
				_htf_DayofWeek(dayofweek(time_tradingday, "America/New_York"))
			str.tonumber(candleSet.csettings.htf) < 60 =>
				str.format_time(candle.o_time, 'm', 'America/New_York')
			str.tonumber(candleSet.csettings.htf) >= 60 =>
				str.format_time(candle.o_time, 'H', 'America/New_York')
			candleSet.csettings.htf == '1M' =>
				str.format_time(candle.o_time, 'M', 'America/New_York')
			=>
				''
		log.info('dow: {1} |{0}|', candle.dow, candleSet.csettings.htf)
		bull = candle.c > candle.o

		candle.body := box.new(bar_index, math.max(candle.o, candle.c), bar_index + 2, math.min(candle.o, candle.c), bull ? htfSettings.bull_border : htfSettings.bear_border, 1, bgcolor = bull ? htfSettings.bull_body : htfSettings.bear_body)
		candle.wick_up := line.new(bar_index + 1, candle.h, bar_index, math.max(candle.o, candle.c), color = bull ? htfSettings.bull_wick : htfSettings.bear_wick)
		candle.wick_down := line.new(bar_index + 1, math.min(candle.o, candle.c), bar_index, candle.l, color = bull ? htfSettings.bull_wick : htfSettings.bear_wick)

		candleSet.candles.unshift(candle)

		if candleSet.candles.size() > candleSet.csettings.max_display
			Candle delCandle = array.pop(candleSet.candles)
			box.delete(delCandle.body)
			line.delete(delCandle.wick_up)
			line.delete(delCandle.wick_down)
			delCandle.dow_label.delete()

	candleSet

_htf_traceUpd(_ln, _lb, _srcIdx, _srcVal, _x2, _bRight, _clr, _style, _sz) =>
	line _oLn = _ln
	label _oLb = _lb
	if bar_index - _srcIdx < 5000
		if na(_oLn)
			_oLn := line.new(_srcIdx, _srcVal, _x2, _srcVal, xloc=xloc.bar_index, color=_clr, style=_htf_LineStyle(_style), width=_sz)
		else
			line.set_xy1(_oLn, _srcIdx, _srcVal)
			line.set_xy2(_oLn, _x2, _srcVal)
			_oLn
		if htfSettings.label_show
			if na(_oLb)
				_oLb := label.new(_bRight, _srcVal, str.tostring(_srcVal), textalign=text.align_center, style=label.style_label_left, size=htfSettings.label_size, color=htfc_color_transparent, textcolor=htfSettings.label_color)
			else
				label.set_xy(_oLb, _bRight, _srcVal)
				label.set_text(_oLb, str.tostring(_srcVal))
				_oLb
	[_oLn, _oLb]

method Update(CandleSet candleSet, int offset, bool showTrace) =>
	if candleSet.candles.size() > 0
		Candle candle = candleSet.candles.first()
		candle.h_idx := high > candle.h ? bar_index : candle.h_idx
		candle.h := high > candle.h ? high : candle.h
		candle.l_idx := low < candle.l ? bar_index : candle.l_idx
		candle.l := low < candle.l ? low : candle.l
		candle.c := close
		candle.c_idx := bar_index

		bull = candle.c > candle.o

		box.set_top(candle.body, candle.o)
		box.set_bottom(candle.body, candle.c)
		box.set_bgcolor(candle.body, bull ? htfSettings.bull_body : htfSettings.bear_body)
		box.set_border_color(candle.body, bull ? htfSettings.bull_border : htfSettings.bear_border)
		line.set_color(candle.wick_up, bull ? htfSettings.bull_wick : htfSettings.bear_wick)
		line.set_color(candle.wick_down, bull ? htfSettings.bull_wick : htfSettings.bear_wick)
		line.set_y1(candle.wick_up, candle.h)
		line.set_y2(candle.wick_up, math.max(candle.o, candle.c))
		line.set_y1(candle.wick_down, candle.l)
		line.set_y2(candle.wick_down, math.min(candle.o, candle.c))

		if barstate.isrealtime or barstate.islast
			candleSet.Reorder(offset)
			if htfSettings.trace_show and showTrace
				int _bR = box.get_right(candle.body)
				int _bL = box.get_left(candle.body)
				[_to, _to_l] = _htf_traceUpd(htfTrace.o, htfTrace.o_l, candle.o_idx, candle.o, _bL, _bR, htfSettings.trace_o_color, htfSettings.trace_o_style, htfSettings.trace_o_size)
				htfTrace.o := _to, htfTrace.o_l := _to_l
				[_tc, _tc_l] = _htf_traceUpd(htfTrace.c, htfTrace.c_l, candle.c_idx, candle.c, _bL, _bR, htfSettings.trace_c_color, htfSettings.trace_c_style, htfSettings.trace_c_size)
				htfTrace.c := _tc, htfTrace.c_l := _tc_l
				[_th, _th_l] = _htf_traceUpd(htfTrace.h, htfTrace.h_l, candle.h_idx, candle.h, line.get_x1(candle.wick_up), _bR, htfSettings.trace_h_color, htfSettings.trace_h_style, htfSettings.trace_h_size)
				htfTrace.h := _th, htfTrace.h_l := _th_l
				[_tl, _tl_l] = _htf_traceUpd(htfTrace.l, htfTrace.l_l, candle.l_idx, candle.l, line.get_x1(candle.wick_down), _bR, htfSettings.trace_l_color, htfSettings.trace_l_style, htfSettings.trace_l_size)
				htfTrace.l := _tl, htfTrace.l_l := _tl_l
	candleSet

int htfCnt = 0
int htfLast = _htf_Enabled()
int htfOffset = htfSettings.offset
if ENABLE_HTF_CANDLES
	for i = 0 to htfSets.size() - 1
		CandleSet _cs = htfSets.get(i)
		if _cs.csettings.show and _htf_ValidTimeframe(_cs.csettings.htf) and htfCnt < htfLast
			bool showTrace = (htfSettings.trace_anchor == 'First Timeframe' and htfCnt == 0) or (htfSettings.trace_anchor == 'Last Timeframe' and htfCnt == htfLast - 1)
			_cs.UpdateTime(htfOffset)
			_cs.Monitor().Update(htfOffset, showTrace).FindImbalance()
			htfCnt += 1
			htfOffset += _cs.candles.size() * htfSettings.width + (_cs.candles.size() > 0 ? (_cs.candles.size() - 1) * htfSettings.buffer : 0) + htfSettings.htf_buffer

f_inSession(_h, _m, _startH, _startM, _endH, _endM) =>
	int _startTotal = _startH * 60 + _startM
	int _endTotal = _endH * 60 + _endM
	int _nowTotal = _h * 60 + _m
	if _startTotal < _endTotal
		_nowTotal >= _startTotal and _nowTotal < _endTotal
	else
		_nowTotal >= _startTotal or _nowTotal < _endTotal

int kz_nyHour = hour(time, "America/New_York")
int kz_nyMin  = minute(time, "America/New_York")

color kz_bg = na
if ENABLE_KILLZONES and timeframe.isintraday
	if kz_showAsian and f_inSession(kz_nyHour, kz_nyMin, kz_asianStart, 0, kz_asianEnd, 0)
		kz_bg := kz_asianColor
	if kz_showLondon and f_inSession(kz_nyHour, kz_nyMin, kz_londonStart, 0, kz_londonEnd, 0)
		kz_bg := kz_londonColor
	if kz_showNYAM and f_inSession(kz_nyHour, kz_nyMin, kz_nyamStart, kz_nyamStartM, kz_nyamEnd, 0)
		kz_bg := kz_nyamColor
	if kz_showNYPM and f_inSession(kz_nyHour, kz_nyMin, kz_nypmStart, kz_nypmStartM, kz_nypmEnd, 0)
		kz_bg := kz_nypmColor
	if kz_showSBAM and f_inSession(kz_nyHour, kz_nyMin, kz_sbamStart, 0, kz_sbamEnd, 0)
		kz_bg := kz_sbamColor
	if kz_showSBPM and f_inSession(kz_nyHour, kz_nyMin, kz_sbpmStart, 0, kz_sbpmEnd, 0)
		kz_bg := kz_sbpmColor

bgcolor(kz_bg)

type SHLevel
	float price
	int startBar
	int priceTime
	bool mitigated = false
	line ln = na
	label lbl = na

_sh_fmtTime(_t) =>
	na(_t) ? "" : " (" + str.format_time(_t, "EEE MM/dd HH:mm", "America/New_York") + ")"

_sh_archive(_histH, _histL, _curH, _curL, _curBar, _curHT, _curLT) =>
	if not na(_curH)
		array.unshift(_histH, SHLevel.new(price = _curH, startBar = _curBar, priceTime = _curHT))
		array.unshift(_histL, SHLevel.new(price = _curL, startBar = _curBar, priceTime = _curLT))
		while array.size(_histH) > sh_historyCount
			SHLevel _old = array.pop(_histH)
			line.delete(_old.ln)
			label.delete(_old.lbl)
		while array.size(_histL) > sh_historyCount
			SHLevel _old = array.pop(_histL)
			line.delete(_old.ln)
			label.delete(_old.lbl)

_sh_processHist(_show, _hist, _isHigh, _color, _style, _name) =>
	if _show and array.size(_hist) > 0
		string _side = _isHigh ? "High - Buyside Liquidity " : "Low - Sellside Liquidity "
		for i = 0 to array.size(_hist) - 1
			SHLevel _lvl = array.get(_hist, i)
			if na(_lvl.price)
				continue
			if _lvl.mitigated and not sh_showMit
				line.delete(_lvl.ln)
				label.delete(_lvl.lbl)
				_lvl.ln := line(na)
				_lvl.lbl := label(na)
				continue
			if not _lvl.mitigated and barstate.isconfirmed
				bool _hit = _isHigh ? close > _lvl.price : close < _lvl.price
				if _hit
					_lvl.mitigated := true
					if not na(_lvl.ln)
						line.set_color(_lvl.ln, sh_mitColor)
						line.set_style(_lvl.ln, line.style_dotted)
			int _x1 = math.max(nz(_lvl.startBar, bar_index - 1), 0)
			int _x2 = bar_index + sh_lineExtend
			color _lineClr = _lvl.mitigated ? sh_mitColor : _color
			color _lblClr = _lvl.mitigated ? sh_mitLblColor : _color
			int _lw = _lvl.mitigated ? sh_mitLineWidth : sh_lineWidth
			string _mitTxt = _lvl.mitigated ? " [Mitigated]" : ""
			string _txt = _name + " " + _side + str.tostring(_lvl.price, format.mintick) + _sh_fmtTime(_lvl.priceTime) + _mitTxt
			string _ls = _lvl.mitigated ? line.style_dotted : f_get_line_style(_style)
			string _sz = _lvl.mitigated ? _ho_getSize(sh_mitLabelSize) : _ho_getSize(sh_labelSize)
			if na(_lvl.ln)
				_lvl.ln := line.new(_x1, _lvl.price, _x2, _lvl.price, color = _lineClr, style = _ls, width = _lw)
			line.set_x2(_lvl.ln, _x2)
			line.set_color(_lvl.ln, _lineClr)
			line.set_width(_lvl.ln, _lw)
			if sh_showLabels
				if na(_lvl.lbl)
					_lvl.lbl := label.new(_x2, _lvl.price, _txt, style = label.style_label_left, color = color.new(color.white, 100), textcolor = _lblClr, size = _sz)
				label.set_x(_lvl.lbl, _x2)
				label.set_text(_lvl.lbl, _txt)
				label.set_textcolor(_lvl.lbl, _lblClr)
				label.set_size(_lvl.lbl, _sz)

_sh_drawCur(_show, _inSess, _curH, _curL, _curHTime, _curLTime, _startBar, _hColor, _lColor, _name) =>
	var line _cLineH=na, var line _cLineL=na
	var label _cLblH=na, var label _cLblL=na
	bool _active = _show and _inSess and not na(_curH)
	if _active
		int _x1 = math.max(nz(_startBar, bar_index - 1), 0)
		int _x2 = bar_index + sh_lineExtend
		string _hTxt = _name + " High* " + str.tostring(_curH, format.mintick) + _sh_fmtTime(_curHTime)
		string _lTxt = _name + " Low* " + str.tostring(_curL, format.mintick) + _sh_fmtTime(_curLTime)
		if na(_cLineH)
			_cLineH := line.new(_x1, _curH, _x2, _curH, color = color.new(_hColor, 60), style = line.style_dotted, width = sh_lineWidth)
			_cLineL := line.new(_x1, _curL, _x2, _curL, color = color.new(_lColor, 60), style = line.style_dotted, width = sh_lineWidth)
		line.set_xy1(_cLineH, _x1, _curH)
		line.set_xy2(_cLineH, _x2, _curH)
		line.set_xy1(_cLineL, _x1, _curL)
		line.set_xy2(_cLineL, _x2, _curL)
		if sh_showLabels
			string _sz = _ho_getSize(sh_labelSize)
			if na(_cLblH)
				_cLblH := label.new(_x2, _curH, _hTxt, style = label.style_label_left, color = color.new(color.white, 100), textcolor = color.new(_hColor, 40), size = _sz)
				_cLblL := label.new(_x2, _curL, _lTxt, style = label.style_label_left, color = color.new(color.white, 100), textcolor = color.new(_lColor, 40), size = _sz)
			label.set_xy(_cLblH, _x2, _curH)
			label.set_text(_cLblH, _hTxt)
			label.set_xy(_cLblL, _x2, _curL)
			label.set_text(_cLblL, _lTxt)
			label.set_size(_cLblH, _sz)
			label.set_size(_cLblL, _sz)
	if not _active and not _inSess
		if not na(_cLineH)
			line.set_xy1(_cLineH, na, na)
			line.set_xy2(_cLineH, na, na)
			line.set_xy1(_cLineL, na, na)
			line.set_xy2(_cLineL, na, na)
		if not na(_cLblH)
			label.set_xy(_cLblH, na, na)
			label.set_xy(_cLblL, na, na)
	[_cLineH, _cLineL, _cLblH, _cLblL]

var array<SHLevel> sh_histAsiaH=array.new<SHLevel>()
var array<SHLevel> sh_histAsiaL=array.new<SHLevel>()
var array<SHLevel> sh_histLonH=array.new<SHLevel>()
var array<SHLevel> sh_histLonL=array.new<SHLevel>()
var array<SHLevel> sh_histNyamH=array.new<SHLevel>()
var array<SHLevel> sh_histNyamL=array.new<SHLevel>()
var array<SHLevel> sh_histNypreH=array.new<SHLevel>()
var array<SHLevel> sh_histNypreL=array.new<SHLevel>()
var array<SHLevel> sh_histNylH=array.new<SHLevel>()
var array<SHLevel> sh_histNylL=array.new<SHLevel>()
var array<SHLevel> sh_histNypmH=array.new<SHLevel>()
var array<SHLevel> sh_histNypmL=array.new<SHLevel>()

var float sh_asiaH=na, var float sh_asiaL=na, var int sh_asiaBar=na, var int sh_asiaHT=na, var int sh_asiaLT=na
var float sh_lonH=na, var float sh_lonL=na, var int sh_lonBar=na, var int sh_lonHT=na, var int sh_lonLT=na
var float sh_nyamH=na, var float sh_nyamL=na, var int sh_nyamBar=na, var int sh_nyamHT=na, var int sh_nyamLT=na
var float sh_nypreH=na, var float sh_nypreL=na, var int sh_nypreBar=na, var int sh_nypreHT=na, var int sh_nypreLT=na
var float sh_nylH=na, var float sh_nylL=na, var int sh_nylBar=na, var int sh_nylHT=na, var int sh_nylLT=na
var float sh_nypmH=na, var float sh_nypmL=na, var int sh_nypmBar=na, var int sh_nypmHT=na, var int sh_nypmLT=na

var bool sh_inAsia=false, var bool sh_inLon=false
var bool sh_inNYAM=false, var bool sh_inNYPre=false, var bool sh_inNYL=false, var bool sh_inNYPM=false

if ENABLE_SESSION_HL and timeframe.isintraday
	bool _isAsia = f_inSession(kz_nyHour, kz_nyMin, kz_asianStart, 0, kz_asianEnd, 0)
	bool _isLon = f_inSession(kz_nyHour, kz_nyMin, kz_londonStart, 0, kz_londonEnd, 0)
	bool _isNYAM = f_inSession(kz_nyHour, kz_nyMin, kz_nyamStart, kz_nyamStartM, kz_nyamEnd, 0)
	bool _isNYPre = f_inSession(kz_nyHour, kz_nyMin, 7, 0, 9, 30)
	bool _isNYL = f_inSession(kz_nyHour, kz_nyMin, 12, 0, 13, 30)
	bool _isNYPM = f_inSession(kz_nyHour, kz_nyMin, kz_nypmStart, kz_nypmStartM, kz_nypmEnd, 0)

	if _isAsia and not sh_inAsia
		sh_asiaH := high, sh_asiaL := low, sh_asiaBar := bar_index
		sh_asiaHT := time, sh_asiaLT := time
		sh_inAsia := true
	else if _isAsia
		if high > nz(sh_asiaH, high)
			sh_asiaH := high, sh_asiaHT := time
		if low < nz(sh_asiaL, low)
			sh_asiaL := low, sh_asiaLT := time
	else
		if sh_inAsia
			_sh_archive(sh_histAsiaH, sh_histAsiaL, sh_asiaH, sh_asiaL, sh_asiaBar, sh_asiaHT, sh_asiaLT)
		sh_inAsia := false

	if _isLon and not sh_inLon
		sh_lonH := high, sh_lonL := low, sh_lonBar := bar_index
		sh_lonHT := time, sh_lonLT := time
		sh_inLon := true
	else if _isLon
		if high > nz(sh_lonH, high)
			sh_lonH := high, sh_lonHT := time
		if low < nz(sh_lonL, low)
			sh_lonL := low, sh_lonLT := time
	else
		if sh_inLon
			_sh_archive(sh_histLonH, sh_histLonL, sh_lonH, sh_lonL, sh_lonBar, sh_lonHT, sh_lonLT)
		sh_inLon := false

	if _isNYAM and not sh_inNYAM
		sh_nyamH := high, sh_nyamL := low, sh_nyamBar := bar_index
		sh_nyamHT := time, sh_nyamLT := time
		sh_inNYAM := true
	else if _isNYAM
		if high > nz(sh_nyamH, high)
			sh_nyamH := high, sh_nyamHT := time
		if low < nz(sh_nyamL, low)
			sh_nyamL := low, sh_nyamLT := time
	else
		if sh_inNYAM
			_sh_archive(sh_histNyamH, sh_histNyamL, sh_nyamH, sh_nyamL, sh_nyamBar, sh_nyamHT, sh_nyamLT)
		sh_inNYAM := false

	if _isNYPre and not sh_inNYPre
		sh_nypreH := high, sh_nypreL := low, sh_nypreBar := bar_index
		sh_nypreHT := time, sh_nypreLT := time
		sh_inNYPre := true
	else if _isNYPre
		if high > nz(sh_nypreH, high)
			sh_nypreH := high, sh_nypreHT := time
		if low < nz(sh_nypreL, low)
			sh_nypreL := low, sh_nypreLT := time
	else
		if sh_inNYPre
			_sh_archive(sh_histNypreH, sh_histNypreL, sh_nypreH, sh_nypreL, sh_nypreBar, sh_nypreHT, sh_nypreLT)
		sh_inNYPre := false

	if _isNYL and not sh_inNYL
		sh_nylH := high, sh_nylL := low, sh_nylBar := bar_index
		sh_nylHT := time, sh_nylLT := time
		sh_inNYL := true
	else if _isNYL
		if high > nz(sh_nylH, high)
			sh_nylH := high, sh_nylHT := time
		if low < nz(sh_nylL, low)
			sh_nylL := low, sh_nylLT := time
	else
		if sh_inNYL
			_sh_archive(sh_histNylH, sh_histNylL, sh_nylH, sh_nylL, sh_nylBar, sh_nylHT, sh_nylLT)
		sh_inNYL := false

	if _isNYPM and not sh_inNYPM
		sh_nypmH := high, sh_nypmL := low, sh_nypmBar := bar_index
		sh_nypmHT := time, sh_nypmLT := time
		sh_inNYPM := true
	else if _isNYPM
		if high > nz(sh_nypmH, high)
			sh_nypmH := high, sh_nypmHT := time
		if low < nz(sh_nypmL, low)
			sh_nypmL := low, sh_nypmLT := time
	else
		if sh_inNYPM
			_sh_archive(sh_histNypmH, sh_histNypmL, sh_nypmH, sh_nypmL, sh_nypmBar, sh_nypmHT, sh_nypmLT)
		sh_inNYPM := false

	_sh_processHist(sh_showAsian,   sh_histAsiaH, true,  sh_asianHColor,  sh_asianStyle,  "Asia")
	_sh_processHist(sh_showAsian,   sh_histAsiaL, false, sh_asianLColor,  sh_asianStyle,  "Asia")
	_sh_processHist(sh_showLondon,  sh_histLonH,  true,  sh_londonHColor, sh_londonStyle, "London")
	_sh_processHist(sh_showLondon,  sh_histLonL,  false, sh_londonLColor, sh_londonStyle, "London")
	_sh_processHist(sh_showNYAM,    sh_histNyamH, true,  sh_nyamHColor,   sh_nyamStyle,   "NY AM")
	_sh_processHist(sh_showNYAM,    sh_histNyamL, false, sh_nyamLColor,   sh_nyamStyle,   "NY AM")
	_sh_processHist(sh_showNYPre,   sh_histNypreH, true,  sh_nypreHColor,  sh_nypreStyle,  "NY Pre-AM")
	_sh_processHist(sh_showNYPre,   sh_histNypreL, false, sh_nypreLColor,  sh_nypreStyle,  "NY Pre-AM")
	_sh_processHist(sh_showNYLunch, sh_histNylH,  true,  sh_nylHColor,    sh_nylStyle,    "NY Lunch")
	_sh_processHist(sh_showNYLunch, sh_histNylL,  false, sh_nylLColor,    sh_nylStyle,    "NY Lunch")
	_sh_processHist(sh_showNYPM,    sh_histNypmH, true,  sh_nypmHColor,   sh_nypmStyle,   "NY PM")
	_sh_processHist(sh_showNYPM,    sh_histNypmL, false, sh_nypmLColor,   sh_nypmStyle,   "NY PM")

	if sh_showCurrent
		_sh_drawCur(sh_showAsian,   _isAsia, sh_asiaH, sh_asiaL, sh_asiaHT, sh_asiaLT, sh_asiaBar, sh_asianHColor,  sh_asianLColor,  "Asia")
		_sh_drawCur(sh_showLondon,  _isLon,  sh_lonH,  sh_lonL,  sh_lonHT,  sh_lonLT,  sh_lonBar,  sh_londonHColor, sh_londonLColor, "London")
		_sh_drawCur(sh_showNYAM,    _isNYAM, sh_nyamH, sh_nyamL, sh_nyamHT, sh_nyamLT, sh_nyamBar, sh_nyamHColor,   sh_nyamLColor,   "NY AM")
		_sh_drawCur(sh_showNYPre,   _isNYPre, sh_nypreH, sh_nypreL, sh_nypreHT, sh_nypreLT, sh_nypreBar, sh_nypreHColor, sh_nypreLColor, "NY Pre-AM")
		_sh_drawCur(sh_showNYLunch, _isNYL,  sh_nylH,  sh_nylL,  sh_nylHT,  sh_nylLT,  sh_nylBar,  sh_nylHColor,    sh_nylLColor,    "NY Lunch")
		_sh_drawCur(sh_showNYPM,    _isNYPM, sh_nypmH, sh_nypmL, sh_nypmHT, sh_nypmLT, sh_nypmBar, sh_nypmHColor,   sh_nypmLColor,   "NY PM")

_lq_draw(_show, _hi, _lo, _hClr, _lClr, _style, _hName, _lName) =>
	var line _lnH = na, var line _lnL = na
	var label _lbH = na, var label _lbL = na
	if _show and not na(_hi)
		if na(_lnH)
			_lnH := line.new(bar_index - 1, _hi, bar_index + 30, _hi, color=_hClr, style=f_get_line_style(_style), width=lq_lineWidth)
			_lnL := line.new(bar_index - 1, _lo, bar_index + 30, _lo, color=_lClr, style=f_get_line_style(_style), width=lq_lineWidth)
		else
			line.set_x1(_lnH, bar_index - 1), line.set_y1(_lnH, _hi), line.set_x2(_lnH, bar_index + 30), line.set_y2(_lnH, _hi)
			line.set_x1(_lnL, bar_index - 1), line.set_y1(_lnL, _lo), line.set_x2(_lnL, bar_index + 30), line.set_y2(_lnL, _lo)
			_lnL
		if lq_showLabels
			string _hTxt = _hName + " " + str.tostring(_hi, format.mintick)
			string _lTxt = _lName + " " + str.tostring(_lo, format.mintick)
			if na(_lbH)
				_lbH := label.new(bar_index + 30, _hi, _hTxt, style=label.style_label_left, color=color.new(color.white, 100), textcolor=_hClr, size=size.small)
				_lbL := label.new(bar_index + 30, _lo, _lTxt, style=label.style_label_left, color=color.new(color.white, 100), textcolor=_lClr, size=size.small)
			else
				label.set_x(_lbH, bar_index + 30), label.set_y(_lbH, _hi), label.set_text(_lbH, _hTxt)
				label.set_x(_lbL, bar_index + 30), label.set_y(_lbL, _lo), label.set_text(_lbL, _lTxt)
				_lbL

if ENABLE_LIQUIDITY
	[lq_dayHigh, lq_dayLow] = request.security(syminfo.tickerid, "D", [high[1], low[1]], lookahead=barmerge.lookahead_on)
	[lq_weekHigh, lq_weekLow] = request.security(syminfo.tickerid, "W", [high[1], low[1]], lookahead=barmerge.lookahead_on)
	[lq_monthHigh, lq_monthLow] = request.security(syminfo.tickerid, "M", [high[1], low[1]], lookahead=barmerge.lookahead_on)
	_lq_draw(lq_showPDH, lq_dayHigh, lq_dayLow, lq_pdhColor, lq_pdlColor, lq_pdStyle, "PDH", "PDL")
	_lq_draw(lq_showPWH, lq_weekHigh, lq_weekLow, lq_pwhColor, lq_pwlColor, lq_pwStyle, "PWH", "PWL")
	_lq_draw(lq_showPMH, lq_monthHigh, lq_monthLow, lq_pmhColor, lq_pmlColor, lq_pmStyle, "PMH", "PML")

var bool rb_showBull=input.bool(true, "Bullish RB", group="㉒ Rejection Blocks", inline="rb1")
var color rb_bullColor=input.color(color.new(#089981, 75), "", group="㉒ Rejection Blocks", inline="rb1")
var bool rb_showBear=input.bool(true, "Bearish RB", group="㉒ Rejection Blocks", inline="rb2")
var color rb_bearColor=input.color(color.new(#f23645, 75), "", group="㉒ Rejection Blocks", inline="rb2")
var int rb_swingLen=input.int(5, "Swing Length", 2, 50, group="㉒ Rejection Blocks", inline="rb3", tooltip="Pivot bars. Higher=larger.")
var float rb_minWickPct=input.float(33.0, "Min Wick %", 0, 90, step=5, group="㉒ Rejection Blocks", inline="rb3", tooltip="Min wick% for RB.")
var string rb_borderStyle=input.string("Dashed", "Border", options=["Solid", "Dashed", "Dotted"], group="㉒ Rejection Blocks", inline="rb4")
var bool rb_extend=input.bool(true, "Extend", group="㉒ Rejection Blocks", inline="rb4")
var bool rb_showLabel=input.bool(true, "Label", group="㉒ Rejection Blocks", inline="rb4")
var bool rb_showTrigger=input.bool(true, "Trigger Line", group="㉒ Rejection Blocks", inline="rb5")
var string rb_triggerStyle=input.string("Dotted", "", options=["Solid", "Dashed", "Dotted"], group="㉒ Rejection Blocks", inline="rb5")
var int rb_triggerWidth=input.int(1, "", 1, 4, group="㉒ Rejection Blocks", inline="rb5", tooltip="Trigger at body.")
var color rb_mitColor=input.color(color.new(color.gray, 92), "Mitigated", group="㉒ Rejection Blocks", inline="rb6")
var int rb_maxBoxes=input.int(10, "Max Boxes", 1, 50, group="㉒ Rejection Blocks", inline="rb6")
var int rb_pruneAge=input.int(500, "Prune After", 0, 5000, group="㉒ Rejection Blocks", inline="rb6", tooltip="Prune after N. 0=off.")

var bool bk_show=input.bool(true, "Show Breakers", group="㉓ Breaker Blocks", inline="bk0")
var int bk_swingLen=input.int(5, "Swing Lookback", 1, 50, group="㉓ Breaker Blocks", inline="bk1", tooltip="Pivot bars.")
var color bk_bullColor=input.color(color.new(#089981, 70), "Bull", group="㉓ Breaker Blocks", inline="bk2")
var color bk_bearColor=input.color(color.new(#f23645, 70), "Bear", group="㉓ Breaker Blocks", inline="bk2")
var bool bk_showLabel=input.bool(true, "Labels", group="㉓ Breaker Blocks", inline="bk3")
var bool bk_extend=input.bool(true, "Extend", group="㉓ Breaker Blocks", inline="bk3")
var int bk_maxBoxes=input.int(10, "Max Boxes", 1, 30, group="㉓ Breaker Blocks", inline="bk4")
var color bk_mitColor=input.color(color.new(color.gray, 92), "Mitigated", group="㉓ Breaker Blocks", inline="bk4")
var int bk_pruneAge=input.int(500, "Prune After", 0, 5000, group="㉓ Breaker Blocks", inline="bk5", tooltip="Prune after N. 0=off.")

var bool mb_show=input.bool(true, "Show Mit Blocks", group="㉔ Mitigation Blocks", inline="mb0")
var int mb_swingLen=input.int(5, "Swing Lookback", 1, 50, group="㉔ Mitigation Blocks", inline="mb1", tooltip="Pivot bars.")
var color mb_bullColor=input.color(color.new(#089981, 75), "Bull", group="㉔ Mitigation Blocks", inline="mb2")
var color mb_bearColor=input.color(color.new(#f23645, 75), "Bear", group="㉔ Mitigation Blocks", inline="mb2")
var bool mb_showLabel=input.bool(true, "Labels", group="㉔ Mitigation Blocks", inline="mb3")
var bool mb_extend=input.bool(true, "Extend", group="㉔ Mitigation Blocks", inline="mb3")
var int mb_maxBoxes=input.int(10, "Max Boxes", 1, 30, group="㉔ Mitigation Blocks", inline="mb4")
var color mb_mitColor=input.color(color.new(color.gray, 92), "Mitigated", group="㉔ Mitigation Blocks", inline="mb4")
var int mb_pruneAge=input.int(500, "Prune After", 0, 5000, group="㉔ Mitigation Blocks", inline="mb5", tooltip="Prune after N. 0=off.")

type RejBlock
	box bx
	line trigLine
	float triggerLevel
	bool isBull
	bool mitigated
	int mit_bar

var array<RejBlock> rb_blocks=array.new<RejBlock>()

bool rb_bullFormed = false
bool rb_bearFormed = false
bool rb_bullMit = false
bool rb_bearMit = false

rb_border = switch rb_borderStyle
	"Solid"  => line.style_solid
	"Dashed" => line.style_dashed
	"Dotted" => line.style_dotted
	=> line.style_dashed

rb_trigStyle = switch rb_triggerStyle
	"Solid"  => line.style_solid
	"Dashed" => line.style_dashed
	"Dotted" => line.style_dotted
	=> line.style_dotted

float rb_pvtHi = ta.pivothigh(high, rb_swingLen, rb_swingLen)
float rb_pvtLo = ta.pivotlow(low, rb_swingLen, rb_swingLen)

f_rbDetect() =>
	bool _bearFormed = false
	bool _bullFormed = false
	if rb_showBear and not na(rb_pvtHi)
		int _pvtOff = rb_swingLen
		float _wickHigh = rb_pvtHi
		float _highestBody = math.max(open[_pvtOff], close[_pvtOff])
		int _leftBar = bar_index - _pvtOff
		for j = 1 to rb_swingLen
			int idx = _pvtOff + j
			float _bt = math.max(open[idx], close[idx])
			if _bt > _highestBody
				_highestBody := _bt
			if bar_index - idx < _leftBar
				_leftBar := bar_index - idx
		for j = 1 to math.min(2, _pvtOff - 1)
			int idx = _pvtOff - j
			float _bt = math.max(open[idx], close[idx])
			if _bt > _highestBody
				_highestBody := _bt
		_highestBody := math.min(_highestBody, _wickHigh)
		float _wickRange = _wickHigh - _highestBody
		float _swingRange = _wickHigh - ta.lowest(low, rb_swingLen * 2 + 1)[0]
		bool _valid = _wickRange > 0 and _swingRange > 0 and (_wickRange / _swingRange * 100 >= rb_minWickPct)
		if _valid
			box _bx = box.new(_leftBar, _wickHigh, bar_index, _highestBody,
							  bgcolor = rb_bearColor,
							  border_color = color.new(rb_bearColor, 60),
							  border_style = rb_border,
							  border_width = 1,
							  text         = rb_showLabel ? "Bear RB" : na,
							  text_halign = text.align_left,
							  text_valign = text.align_bottom,
							  text_size = size.tiny,
							  text_color = color.new(rb_bearColor, 30))
			line _tl = rb_showTrigger ? line.new(_leftBar, _highestBody, bar_index, _highestBody,
							  color = color.new(rb_bearColor, 40),
							  style = rb_trigStyle,
							  width = rb_triggerWidth) : na
			rb_blocks.push(RejBlock.new(_bx, _tl, _highestBody, false, false, 0))
			_bearFormed := true
			if wh_enable and wh_formations
				alert(_wh_json("Bear RB Formed", _wickHigh, _highestBody), alert.freq_once_per_bar_close)
			while rb_blocks.size() > rb_maxBoxes * 2
				RejBlock _del = rb_blocks.shift()
				box.delete(_del.bx)
				line.delete(_del.trigLine)

	if rb_showBull and not na(rb_pvtLo)
		int _pvtOff = rb_swingLen
		float _wickLow = rb_pvtLo
		float _lowestBody = math.min(open[_pvtOff], close[_pvtOff])
		int _leftBar = bar_index - _pvtOff
		for j = 1 to rb_swingLen
			int idx = _pvtOff + j
			float _bb = math.min(open[idx], close[idx])
			if _bb < _lowestBody
				_lowestBody := _bb
			if bar_index - idx < _leftBar
				_leftBar := bar_index - idx
		for j = 1 to math.min(2, _pvtOff - 1)
			int idx = _pvtOff - j
			float _bb = math.min(open[idx], close[idx])
			if _bb < _lowestBody
				_lowestBody := _bb
		_lowestBody := math.max(_lowestBody, _wickLow)
		float _wickRange = _lowestBody - _wickLow
		float _swingRange = ta.highest(high, rb_swingLen * 2 + 1)[0] - _wickLow
		bool _valid = _wickRange > 0 and _swingRange > 0 and (_wickRange / _swingRange * 100 >= rb_minWickPct)
		if _valid
			box _bx = box.new(_leftBar, _lowestBody, bar_index, _wickLow,
							  bgcolor = rb_bullColor,
							  border_color = color.new(rb_bullColor, 60),
							  border_style = rb_border,
							  border_width = 1,
							  text         = rb_showLabel ? "Bull RB" : na,
							  text_halign = text.align_left,
							  text_valign = text.align_top,
							  text_size = size.tiny,
							  text_color = color.new(rb_bullColor, 30))
			line _tl = rb_showTrigger ? line.new(_leftBar, _lowestBody, bar_index, _lowestBody,
							  color = color.new(rb_bullColor, 40),
							  style = rb_trigStyle,
							  width = rb_triggerWidth) : na
			rb_blocks.push(RejBlock.new(_bx, _tl, _lowestBody, true, false, 0))
			_bullFormed := true
			if wh_enable and wh_formations
				alert(_wh_json("Bull RB Formed", _lowestBody, _wickLow), alert.freq_once_per_bar_close)
			while rb_blocks.size() > rb_maxBoxes * 2
				RejBlock _del = rb_blocks.shift()
				box.delete(_del.bx)
				line.delete(_del.trigLine)
	[_bearFormed, _bullFormed]

if ENABLE_REJECTION_BLK
	[_rbBearF, _rbBullF] = f_rbDetect()
	rb_bearFormed := _rbBearF
	rb_bullFormed := _rbBullF

f_rbManage() =>
	bool _bullMit = false
	bool _bearMit = false
	for i = rb_blocks.size() - 1 to 0 by 1
		RejBlock _rb = rb_blocks.get(i)
		if not _rb.mitigated
			bool _hit = _rb.isBull ? (close < box.get_bottom(_rb.bx)) : (close > box.get_top(_rb.bx))
			if _hit
				_rb.mitigated := true
				_rb.mit_bar := bar_index
				if _rb.isBull
					_bullMit := true
					if wh_enable and wh_mitigations
						alert(_wh_json("Bull RB Mitigated", box.get_top(_rb.bx), box.get_bottom(_rb.bx)), alert.freq_once_per_bar)
				else
					_bearMit := true
					if wh_enable and wh_mitigations
						alert(_wh_json("Bear RB Mitigated", box.get_top(_rb.bx), box.get_bottom(_rb.bx)), alert.freq_once_per_bar)
				box.set_bgcolor(_rb.bx, rb_mitColor)
				box.set_border_color(_rb.bx, rb_mitColor)
				box.set_text_color(_rb.bx, color.new(color.gray, 70))
				if not na(_rb.trigLine)
					line.set_color(_rb.trigLine, rb_mitColor)
			else if rb_extend
				box.set_right(_rb.bx, bar_index + 1)
				if not na(_rb.trigLine)
					line.set_x2(_rb.trigLine, bar_index + 1)
		else
			if rb_pruneAge > 0 and (bar_index - _rb.mit_bar) > rb_pruneAge
				box.delete(_rb.bx)
				line.delete(_rb.trigLine)
				rb_blocks.remove(i)
		true
	[_bullMit, _bearMit]

if ENABLE_REJECTION_BLK and rb_blocks.size() > 0
	[_rbBullM, _rbBearM] = f_rbManage()
	rb_bullMit := _rbBullM
	rb_bearMit := _rbBearM

type SwingPt
	float price
	int bar
	float bodyTop
	float bodyBot
	float wickHi
	float wickLo

type PendingBrk
	float trigPrice
	float bodyTop
	float bodyBot
	float wickHi
	float wickLo
	int zoneBar
	bool isBull

var array<OrderBlock> bk_blocks=array.new<OrderBlock>()
var array<OrderBlock> mb_blocks=array.new<OrderBlock>()

var array<SwingPt> bm_swHi=array.new<SwingPt>()
var array<SwingPt> bm_swLo=array.new<SwingPt>()
var array<PendingBrk> bm_pendBrk=array.new<PendingBrk>()

bool bk_bullFormed = false
bool bk_bearFormed = false
bool bk_bullMit = false
bool bk_bearMit = false
bool mb_bullFormed = false
bool mb_bearFormed = false
bool mb_bullMit = false
bool mb_bearMit = false

f_lastDirCandle(int _pvtOffset, int _dir) =>
	float _bTop = na
	float _bBot = na
	float _wH = na
	float _wL = na
	for k = _pvtOffset to _pvtOffset + 3
		bool _match = _dir > 0 ? close[k] > open[k] : close[k] < open[k]
		if _match
			_bTop := math.max(open[k], close[k])
			_bBot := math.min(open[k], close[k])
			_wH := high[k]
			_wL := low[k]
			break
	if na(_bTop)
		_bTop := math.max(open[_pvtOffset], close[_pvtOffset])
		_bBot := math.min(open[_pvtOffset], close[_pvtOffset])
		_wH := high[_pvtOffset]
		_wL := low[_pvtOffset]
	[_bTop, _bBot, _wH, _wL]

int _bmSwLen = math.max(bk_swingLen, mb_swingLen)
float bm_pvtHi = ta.pivothigh(high, _bmSwLen, _bmSwLen)
float bm_pvtLo = ta.pivotlow(low, _bmSwLen, _bmSwLen)

f_breakerMitProcess() =>
	bool _mbBearF = false
	bool _mbBullF = false
	bool _bkBullF = false
	bool _bkBearF = false
	bool _bkBullM = false
	bool _bkBearM = false
	bool _mbBullM = false
	bool _mbBearM = false
	if not na(bm_pvtHi)
		int _off = _bmSwLen
		[_bTop, _bBot, _wH, _wL] = f_lastDirCandle(_off, 1)
		bm_swHi.push(SwingPt.new(bm_pvtHi, bar_index - _off, _bTop, _bBot, _wH, _wL))
		if bm_swHi.size() > 30
			bm_swHi.shift()

	if not na(bm_pvtLo)
		int _off = _bmSwLen
		[_bTop, _bBot, _wH, _wL] = f_lastDirCandle(_off, -1)
		bm_swLo.push(SwingPt.new(bm_pvtLo, bar_index - _off, _bTop, _bBot, _wH, _wL))
		if bm_swLo.size() > 30
			bm_swLo.shift()

	if mb_show and barstate.isconfirmed
		if bm_swLo.size() > 0
			for i = bm_swLo.size() - 1 to 0 by 1
				SwingPt _sw = bm_swLo.get(i)
				if close < _sw.price
					box _bx = box.new(_sw.bar, _sw.bodyTop, bar_index, _sw.bodyBot,
						 bgcolor = mb_bearColor,
						 border_color = color.new(mb_bearColor, 60),
						 border_style = line.style_dashed,
						 border_width = 1,
						 text         = mb_showLabel ? "Bear MB" : na,
						 text_halign = text.align_left,
						 text_valign = text.align_bottom,
						 text_size = size.tiny,
						 text_color = color.new(mb_bearColor, 30))
					float _mt = (_sw.bodyTop + _sw.bodyBot) / 2
					line _mtL = line.new(_sw.bar, _mt, bar_index, _mt,
						 color = color.new(mb_bearColor, 60),
						 style = line.style_dashed, width = 1)
					mb_blocks.push(OrderBlock.new(_bx, _mtL, _sw.bodyTop, _sw.bodyBot, false, false, 0))
					_mbBearF := true
					if wh_enable and wh_formations
						alert(_wh_json("Bear MB Formed", _sw.bodyTop, _sw.bodyBot), alert.freq_once_per_bar_close)
					bm_swLo.remove(i)
					while mb_blocks.size() > mb_maxBoxes * 2
						OrderBlock _del = mb_blocks.shift()
						box.delete(_del.bx)
						if not na(_del.mtLine)
							line.delete(_del.mtLine)
					break

		if bm_swHi.size() > 0
			for i = bm_swHi.size() - 1 to 0 by 1
				SwingPt _sw = bm_swHi.get(i)
				if close > _sw.price
					box _bx = box.new(_sw.bar, _sw.bodyTop, bar_index, _sw.bodyBot,
						 bgcolor = mb_bullColor,
						 border_color = color.new(mb_bullColor, 60),
						 border_style = line.style_dashed,
						 border_width = 1,
						 text         = mb_showLabel ? "Bull MB" : na,
						 text_halign = text.align_left,
						 text_valign = text.align_top,
						 text_size = size.tiny,
						 text_color = color.new(mb_bullColor, 30))
					float _mt = (_sw.bodyTop + _sw.bodyBot) / 2
					line _mtL = line.new(_sw.bar, _mt, bar_index, _mt,
						 color = color.new(mb_bullColor, 60),
						 style = line.style_dashed, width = 1)
					mb_blocks.push(OrderBlock.new(_bx, _mtL, _sw.bodyTop, _sw.bodyBot, true, false, 0))
					_mbBullF := true
					if wh_enable and wh_formations
						alert(_wh_json("Bull MB Formed", _sw.bodyTop, _sw.bodyBot), alert.freq_once_per_bar_close)
					bm_swHi.remove(i)
					while mb_blocks.size() > mb_maxBoxes * 2
						OrderBlock _del = mb_blocks.shift()
						box.delete(_del.bx)
						if not na(_del.mtLine)
							line.delete(_del.mtLine)
					break

	if bk_show
		if not na(bm_pvtLo) and bm_swLo.size() >= 2
			SwingPt _newLo = bm_swLo.last()
			for i = bm_swLo.size() - 2 to math.max(0, bm_swLo.size() - 6) by 1
				SwingPt _oldLo = bm_swLo.get(i)
				if _newLo.price < _oldLo.price and bm_swHi.size() > 0
					for h = bm_swHi.size() - 1 to 0 by 1
						SwingPt _hi = bm_swHi.get(h)
						if _hi.bar > _oldLo.bar and _hi.bar < _newLo.bar
							bm_pendBrk.push(PendingBrk.new(
								 _hi.price, _hi.bodyTop, _hi.bodyBot,
								 _hi.wickHi, _hi.wickLo, _hi.bar, true))
							break
					break

		if not na(bm_pvtHi) and bm_swHi.size() >= 2
			SwingPt _newHi = bm_swHi.last()
			for i = bm_swHi.size() - 2 to math.max(0, bm_swHi.size() - 6) by 1
				SwingPt _oldHi = bm_swHi.get(i)
				if _newHi.price > _oldHi.price and bm_swLo.size() > 0
					for l = bm_swLo.size() - 1 to 0 by 1
						SwingPt _lo = bm_swLo.get(l)
						if _lo.bar > _oldHi.bar and _lo.bar < _newHi.bar
							bm_pendBrk.push(PendingBrk.new(
								 _lo.price, _lo.bodyTop, _lo.bodyBot,
								 _lo.wickHi, _lo.wickLo, _lo.bar, false))
							break
					break

	if bk_show and barstate.isconfirmed and bm_pendBrk.size() > 0
		for i = bm_pendBrk.size() - 1 to 0 by 1
			PendingBrk _p = bm_pendBrk.get(i)
			bool _confirmed = _p.isBull ? close > _p.trigPrice : close < _p.trigPrice
			if _confirmed
				color _clr = _p.isBull ? bk_bullColor : bk_bearColor
				string _lbl = _p.isBull ? "Bull BRK" : "Bear BRK"
				box _bx = box.new(_p.zoneBar, _p.bodyTop, bar_index, _p.bodyBot,
					 bgcolor = _clr,
					 border_color = color.new(_clr, 60),
					 border_style = line.style_solid,
					 border_width = 1,
					 text = bk_showLabel ? _lbl : na,
					 text_halign = text.align_left,
					 text_valign = _p.isBull ? text.align_top : text.align_bottom,
					 text_size = size.tiny,
					 text_color = color.new(_clr, 30))
				float _mt = (_p.bodyTop + _p.bodyBot) / 2
				line _mtL = line.new(_p.zoneBar, _mt, bar_index, _mt,
					 color = color.new(_clr, 60),
					 style = line.style_dashed, width = 1)
				bk_blocks.push(OrderBlock.new(_bx, _mtL, _p.bodyTop, _p.bodyBot, _p.isBull, false, 0))
				if _p.isBull
					_bkBullF := true
				else
					_bkBearF := true
				if wh_enable and wh_formations
					alert(_wh_json(_lbl + " Confirmed", _p.bodyTop, _p.bodyBot), alert.freq_once_per_bar_close)
				bm_pendBrk.remove(i)
				while bk_blocks.size() > bk_maxBoxes * 2
					OrderBlock _del = bk_blocks.shift()
					box.delete(_del.bx)
					if not na(_del.mtLine)
						line.delete(_del.mtLine)

	if bm_pendBrk.size() > 0
		for i = bm_pendBrk.size() - 1 to 0 by 1
			if bar_index - bm_pendBrk.get(i).zoneBar > 200
				bm_pendBrk.remove(i)
			true

	if bk_blocks.size() > 0
		for i = bk_blocks.size() - 1 to 0 by 1
			OrderBlock _ob = bk_blocks.get(i)
			if not _ob.mitigated
				bool _hit = _ob.isBull ? close < _ob.bodyBot : close > _ob.bodyTop
				if _hit and barstate.isconfirmed
					_ob.mitigated := true
					_ob.mit_bar := bar_index
					box.set_bgcolor(_ob.bx, bk_mitColor)
					box.set_border_color(_ob.bx, bk_mitColor)
					box.set_text_color(_ob.bx, color.new(color.gray, 70))
					if not na(_ob.mtLine)
						line.set_color(_ob.mtLine, color.new(color.gray, 85))
					if _ob.isBull
						_bkBullM := true
					else
						_bkBearM := true
				else if bk_extend
					box.set_right(_ob.bx, bar_index + 1)
					if not na(_ob.mtLine)
						line.set_x2(_ob.mtLine, bar_index + 1)
			else
				if bk_pruneAge > 0 and (bar_index - _ob.mit_bar) > bk_pruneAge
					bk_blocks.remove(i)
					box.delete(_ob.bx)
					if not na(_ob.mtLine)
						line.delete(_ob.mtLine)
			true

	if mb_blocks.size() > 0
		for i = mb_blocks.size() - 1 to 0 by 1
			OrderBlock _ob = mb_blocks.get(i)
			if not _ob.mitigated
				bool _hit = _ob.isBull ? close < _ob.bodyBot : close > _ob.bodyTop
				if _hit and barstate.isconfirmed
					_ob.mitigated := true
					_ob.mit_bar := bar_index
					box.set_bgcolor(_ob.bx, mb_mitColor)
					box.set_border_color(_ob.bx, mb_mitColor)
					box.set_text_color(_ob.bx, color.new(color.gray, 70))
					if not na(_ob.mtLine)
						line.set_color(_ob.mtLine, color.new(color.gray, 85))
					if _ob.isBull
						_mbBullM := true
					else
						_mbBearM := true
				else if mb_extend
					box.set_right(_ob.bx, bar_index + 1)
					if not na(_ob.mtLine)
						line.set_x2(_ob.mtLine, bar_index + 1)
			else
				if mb_pruneAge > 0 and (bar_index - _ob.mit_bar) > mb_pruneAge
					mb_blocks.remove(i)
					box.delete(_ob.bx)
					if not na(_ob.mtLine)
						line.delete(_ob.mtLine)
			true
	[_mbBearF, _mbBullF, _bkBullF, _bkBearF, _bkBullM, _bkBearM, _mbBullM, _mbBearM]

if ENABLE_BREAKER_MIT
	[_r1, _r2, _r3, _r4, _r5, _r6, _r7, _r8] = f_breakerMitProcess()
	mb_bearFormed := _r1
	mb_bullFormed := _r2
	bk_bullFormed := _r3
	bk_bearFormed := _r4
	bk_bullMit := _r5
	bk_bearMit := _r6
	mb_bullMit := _r7
	mb_bearMit := _r8

alertcondition(rb_bullFormed, title = 'Bull RB Formed', message = 'Bull RB formed {{ticker}} {{interval}}')
alertcondition(rb_bearFormed, title = 'Bear RB Formed', message = 'Bear RB formed {{ticker}} {{interval}}')
alertcondition(rb_bullMit,    title = 'Bull RB Mitigated', message = 'Bull RB mitigated {{ticker}} {{interval}}')
alertcondition(rb_bearMit,    title = 'Bear RB Mitigated', message = 'Bear RB mitigated {{ticker}} {{interval}}')

alertcondition(bk_bullFormed, title = 'Bull Breaker Formed',    message = 'Bull BK formed {{ticker}} {{interval}}')
alertcondition(bk_bearFormed, title = 'Bear Breaker Formed',    message = 'Bear BK formed {{ticker}} {{interval}}')
alertcondition(bk_bullMit,    title = 'Bull Breaker Mitigated', message = 'Bull BK mitigated {{ticker}} {{interval}}')
alertcondition(bk_bearMit,    title = 'Bear Breaker Mitigated', message = 'Bear BK mitigated {{ticker}} {{interval}}')

alertcondition(mb_bullFormed, title = 'Bull MB Formed',    message = 'Bull MB formed {{ticker}} {{interval}}')
alertcondition(mb_bearFormed, title = 'Bear MB Formed',    message = 'Bear MB formed {{ticker}} {{interval}}')
alertcondition(mb_bullMit,    title = 'Bull MB Mitigated', message = 'Bull MB mitigated {{ticker}} {{interval}}')
alertcondition(mb_bearMit,    title = 'Bear MB Mitigated', message = 'Bear MB mitigated {{ticker}} {{interval}}')

var string pda_range=input.string("Previous Day", "Dealing Range", options=["Previous Day", "Previous Week", "Previous Month"], group="㉕ PD Array Scanner", tooltip="Range for EQ. Premium/Discount.")
var bool pda_showEQ=input.bool(true, "EQ Line", group="㉕ PD Array Scanner", inline="pda1")
var color pda_eqColor=input.color(color.new(color.white, 30), "", group="㉕ PD Array Scanner", inline="pda1")
var bool pda_showTable=input.bool(true, "Table", group="㉕ PD Array Scanner", inline="pda2")
var string pda_tblPos=input.string("Top Right", "", options=["Top Left", "Top Right", "Bottom Left", "Bottom Right"], group="㉕ PD Array Scanner", inline="pda2")
var bool pda_showConfl=input.bool(true, "Confluence Zones", group="㉕ PD Array Scanner", inline="pda3")
var color pda_conflClr=input.color(color.new(#ffeb3b, 80), "", group="㉕ PD Array Scanner", inline="pda3")
var int pda_minConfl=input.int(2, "Min Overlap Count ", 2, 5, group="㉕ PD Array Scanner", inline="pda4", tooltip="Min overlap for confluence.")

type PDZone
	float top
	float bot
	string kind
	bool isBull
	int rank
	int score

[pda_dayHi, pda_dayLo]   = request.security(syminfo.tickerid, "D", [high[1], low[1]], lookahead = barmerge.lookahead_on)
[pda_weekHi, pda_weekLo] = request.security(syminfo.tickerid, "W", [high[1], low[1]], lookahead = barmerge.lookahead_on)
[pda_moHi, pda_moLo]     = request.security(syminfo.tickerid, "M", [high[1], low[1]], lookahead = barmerge.lookahead_on)

pda_rankFor(_kind) =>
	switch _kind
		"MB" => 1
		"BRK" => 2
		"VI" => 3
		"GAP" => 3
		"OB" => 5
		"RB" => 6
		=> 4

pda_addZone(_zones, _top, _bot, _kind, _isBull) =>
	if not na(_top) and not na(_bot) and _top > _bot
		_zones.push(PDZone.new(_top, _bot, _kind, _isBull, pda_rankFor(_kind), 0))

pda_scanOBArr(_zones, _arr, _kind) =>
	for i = 0 to math.max(_arr.size() - 1, 0)
		if i < _arr.size()
			OrderBlock _ob = _arr.get(i)
			if not _ob.mitigated
				pda_addZone(_zones, _ob.bodyTop, _ob.bodyBot, _kind, _ob.isBull)

pda_scanBoxArr(_zones, _arr, _kind, bool _isBull) =>
	for i = 0 to math.max(_arr.size() - 1, 0)
		if i < _arr.size()
			box _bx = _arr.get(i)
			if not na(_bx)
				pda_addZone(_zones, box.get_top(_bx), box.get_bottom(_bx), _kind, _isBull)

pda_sortByRankDesc(_arr) =>
	for i = 1 to math.max(_arr.size() - 1, 0)
		if i < _arr.size()
			PDZone _key = _arr.get(i)
			int j = i - 1
			while j >= 0 and _arr.get(j).rank < _key.rank
				_arr.set(j + 1, _arr.get(j))
				j -= 1
			_arr.set(j + 1, _key)

pda_renderRows(_tbl, _arr, int _count, int _startRow, int _minC) =>
	int _r = _startRow
	for i = 0 to math.max(_count - 1, 0)
		if i < _count
			PDZone _z = _arr.get(i)
			string _nm = str.tostring(_z.rank) + ". " + _z.kind + (_z.isBull ? "+" : "-")
			string _rn = str.tostring(_z.bot, format.mintick) + "-" + str.tostring(_z.top, format.mintick)
			color _sc = _z.score >= _minC ? #ffeb3b : color.new(color.white, 40)
			table.cell(_tbl, 0, _r, _nm, text_color = color.white, text_size = size.tiny, text_halign = text.align_left)
			table.cell(_tbl, 1, _r, _rn, text_color = color.new(color.white, 30), text_size = size.tiny)
			table.cell(_tbl, 2, _r, _z.score > 1 ? str.tostring(_z.score) : "-", text_color = _sc, text_size = size.tiny)
			_r += 1
	_r

var line pda_eqLine=na
var array<box> pda_conflBoxes=array.new<box>()
var table pda_tbl=na

f_pdaScanner() =>
	line _eqLine = pda_eqLine
	table _tbl = pda_tbl
	float _rangeHi = switch pda_range
		"Previous Day" => pda_dayHi
		"Previous Week" => pda_weekHi
		"Previous Month" => pda_moHi
		=> pda_dayHi
	float _rangeLo = switch pda_range
		"Previous Day" => pda_dayLo
		"Previous Week" => pda_weekLo
		"Previous Month" => pda_moLo
		=> pda_dayLo
	float _eq = nz((_rangeHi + _rangeLo) / 2)

	if pda_showEQ and not na(_rangeHi)
		if na(_eqLine)
			_eqLine := line.new(bar_index, _eq, bar_index + 1, _eq, color = pda_eqColor, style = line.style_dashed, width = 1)
		else
			line.set_xy1(_eqLine, bar_index - 50, _eq)
			line.set_xy2(_eqLine, bar_index + 20, _eq)

	if barstate.islast
		var array<PDZone> _zones=array.new<PDZone>()
		_zones.clear()

		pda_scanOBArr(_zones, ob_bulls, "OB")
		pda_scanOBArr(_zones, ob_bears, "OB")
		pda_scanOBArr(_zones, ob_mtf1, "OB")
		pda_scanOBArr(_zones, ob_mtf2, "OB")
		pda_scanOBArr(_zones, ob_mtf3, "OB")
		pda_scanOBArr(_zones, bk_blocks, "BRK")
		pda_scanOBArr(_zones, mb_blocks, "MB")
		if rb_blocks.size() > 0
			for i = 0 to rb_blocks.size() - 1
				RejBlock _rb = rb_blocks.get(i)
				if not _rb.mitigated and not na(_rb.bx)
					pda_addZone(_zones, box.get_top(_rb.bx), box.get_bottom(_rb.bx), "RB", _rb.isBull)
		pda_scanBoxArr(_zones, _bullBoxesFVG, "FVG", true)
		pda_scanBoxArr(_zones, _bearBoxesFVG, "FVG", false)
		pda_scanBoxArr(_zones, _bullishvi, "VI", true)
		pda_scanBoxArr(_zones, _bearishvi, "VI", false)
		pda_scanBoxArr(_zones, _bullishifvg, "I.FVG", true)
		pda_scanBoxArr(_zones, _bearishifvg, "I.FVG", false)
		pda_scanBoxArr(_zones, bullInvFVG, "Inv.FVG", true)
		pda_scanBoxArr(_zones, bearInvFVG, "Inv.FVG", false)
		pda_scanBoxArr(_zones, _gapsboxesbu, "GAP", true)
		pda_scanBoxArr(_zones, _gapsboxesbe, "GAP", false)

		if _zones.size() > 0
			for i = 0 to _zones.size() - 1
				PDZone _z1 = _zones.get(i)
				int _cnt = 1
				for j = 0 to _zones.size() - 1
					if j != i
						PDZone _z2 = _zones.get(j)
						if _z1.top >= _z2.bot and _z2.top >= _z1.bot and _z1.kind != _z2.kind
							_cnt += 1
				_z1.score := _cnt

		if pda_conflBoxes.size() > 0
			for i = pda_conflBoxes.size() - 1 to 0 by 1
				box.delete(pda_conflBoxes.get(i))
		pda_conflBoxes.clear()

		if pda_showConfl and _zones.size() > 0
			for i = 0 to _zones.size() - 1
				PDZone _z = _zones.get(i)
				if _z.score >= pda_minConfl
					pda_conflBoxes.push(box.new(bar_index - 3, _z.top, bar_index + 15, _z.bot,
						 border_color = pda_conflClr, border_width = 2, border_style = line.style_dotted,
						 bgcolor = color.new(#ffeb3b, _z.score >= 4 ? 65 : _z.score >= 3 ? 75 : 82)))

		if pda_showTable
			var array<PDZone> _premZones=array.new<PDZone>()
			var array<PDZone> _discZones=array.new<PDZone>()
			_premZones.clear()
			_discZones.clear()
			if _zones.size() > 0
				for i = 0 to _zones.size() - 1
					PDZone _z = _zones.get(i)
					if (_z.top + _z.bot) / 2.0 > _eq
						_premZones.push(_z)
					else
						_discZones.push(_z)

			pda_sortByRankDesc(_premZones)
			pda_sortByRankDesc(_discZones)

			int _maxRows = 4
			int _premCount = math.min(_premZones.size(), _maxRows)
			int _discCount = math.min(_discZones.size(), _maxRows)
			int _totalRows = 3 + _premCount + 1 + _discCount

			if not na(_tbl)
				table.delete(_tbl)

			string _tblPosVal = switch pda_tblPos
				"Top Left" => position.top_left
				"Bottom Left" => position.bottom_left
				"Bottom Right" => position.bottom_right
				=> position.top_right

			_tbl := table.new(_tblPosVal, 3, _totalRows + 1,
				 bgcolor = color.new(#1a1a2e, 5), border_width = 1, border_color = color.new(#333355, 20),
				 frame_width = 2, frame_color = color.new(#555577, 10))

			string _locLabel = close > _eq ? "PREMIUM" : "DISCOUNT"
			color _locColor = close > _eq ? color.new(#f23645, 40) : color.new(#089981, 40)

			table.cell(_tbl, 0, 0, "PD Array Scanner", text_color = color.white, text_size = size.small, bgcolor = color.new(#16213e, 0))
			table.merge_cells(_tbl, 0, 0, 2, 0)
			table.cell(_tbl, 0, 1, "EQ: " + str.tostring(_eq, format.mintick), text_color = pda_eqColor, text_size = size.tiny)
			table.cell(_tbl, 1, 1, _locLabel, text_color = color.white, text_size = size.tiny, bgcolor = _locColor)
			table.cell(_tbl, 2, 1, str.tostring(_zones.size()) + " zones", text_color = color.new(color.white, 40), text_size = size.tiny)

			table.cell(_tbl, 0, 2, "PREMIUM", text_color = #f23645, text_size = size.tiny, text_halign = text.align_left)
			table.cell(_tbl, 1, 2, "Zone", text_color = color.new(color.white, 40), text_size = size.tiny)
			table.cell(_tbl, 2, 2, "Conf", text_color = color.new(color.white, 40), text_size = size.tiny)

			int _row = pda_renderRows(_tbl, _premZones, _premCount, 3, pda_minConfl)
			table.cell(_tbl, 0, _row, "=== EQ " + str.tostring(_eq, format.mintick) + " ===",
				 text_color = pda_eqColor, text_size = size.tiny, text_halign = text.align_center)
			table.merge_cells(_tbl, 0, _row, 2, _row)
			_row += 1
			pda_renderRows(_tbl, _discZones, _discCount, _row, pda_minConfl)
	[_eqLine, _tbl]

if ENABLE_PDA_SCANNER
	[_pEq, _pTbl] = f_pdaScanner()
	pda_eqLine := _pEq
	pda_tbl := _pTbl

var label _tfWarning=na
if barstate.islast and not timeframe.isintraday
	bool _anyIntraday = ENABLE_HOURLY_OPEN or ENABLE_ORDER_BLOCKS or ENABLE_IMBALANCES or ENABLE_KILLZONES or ENABLE_SESSION_HL
	if _anyIntraday
		if na(_tfWarning)
			_tfWarning := label.new(bar_index, close, "⚠ Switch to intraday for: " +
				 (ENABLE_HOURLY_OPEN ? "Hourly Open, " : "") +
				 (ENABLE_ORDER_BLOCKS ? "Order Blocks, " : "") +
				 (ENABLE_IMBALANCES ? "Imbalances, " : "") +
				 (ENABLE_KILLZONES ? "Killzones, " : "") +
				 (ENABLE_SESSION_HL ? "Session H/L" : ""),
				 style = label.style_label_down, color = color.new(#ff9800, 20),
				 textcolor = color.white, size = size.normal)
		else
			label.set_x(_tfWarning, bar_index)
			label.set_y(_tfWarning, close)

